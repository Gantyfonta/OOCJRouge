
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Moinkcraft: The Creative Update</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press+Start+2P', cursive;
            background: #0d0d1a;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #4a90e2;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            image-rendering: pixelated;
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #title-screen {
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            text-align: center;
            padding: 20px;
            overflow-y: auto;
        }

        #mode-selection-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 210;
        }

        #pause-menu {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 150;
            text-align: center;
        }

        .floating-numbers {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }

        .time-particle {
            position: absolute;
            font-size: 20px;
            color: rgba(212, 175, 55, 0.2);
            animation: driftUp 10s linear infinite;
        }

        @keyframes driftUp {
            0% { transform: translateY(110vh) rotate(0deg); opacity: 0; }
            20% { opacity: 0.5; }
            80% { opacity: 0.5; }
            100% { transform: translateY(-10vh) rotate(360deg); opacity: 0; }
        }

        .hero-scene {
            position: relative;
            width: 160px;
            height: 180px;
            margin-bottom: 20px;
            z-index: 10;
        }

        .title-clock {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background: #f1c40f;
            border: 6px solid #b8860b;
            border-radius: 50%;
            box-shadow: 0 6px 0 #8b6b00, 0 10px 20px rgba(0,0,0,0.5);
        }

        .title-clock::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 3px; height: 25px;
            background: #333;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: translate(-50%, -100%) rotate(0deg); }
            to { transform: translate(-50%, -100%) rotate(360deg); }
        }

        .title-pig {
            position: absolute;
            width: 50px;
            height: 40px;
            background: #ffb6c1;
            bottom: 95px;
            left: 50%;
            margin-left: -25px;
            border-bottom: 4px solid #ff69b4;
            border-radius: 4px;
            animation: pigJump 1.2s cubic-bezier(0.45, 0, 0.55, 1) infinite;
        }

        .title-pig::before { content: ''; position: absolute; right: -6px; top: 18px; width: 10px; height: 14px; background: #ff69b4; border-right: 2px solid #c71585; border-radius: 2px; }
        .title-pig::after { content: ''; position: absolute; right: 10px; top: 10px; width: 6px; height: 6px; background: #000; box-shadow: -18px 0 0 #000; border-radius: 1px; }

        @keyframes pigJump {
            0%, 100% { transform: translateY(0) scaleY(1); }
            50% { transform: translateY(-80px) scaleY(1.1); }
            95% { transform: translateY(6px) scaleY(0.75); }
        }

        .game-title {
            font-size: 28px;
            color: #ffb6c1;
            text-shadow: 4px 4px 0px #c71585, 6px 6px 0px rgba(0,0,0,0.4);
            margin-bottom: 20px;
            letter-spacing: -2px;
            z-index: 10;
            position: relative;
        }

        .game-title span { color: #f1c40f; text-shadow: 4px 4px 0px #b8860b; }

        .worlds-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 400px;
            z-index: 10;
            padding: 10px;
        }

        .world-slot {
            background: #444;
            border: 4px solid;
            border-color: #666 #222 #222 #666;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .world-slot.empty { opacity: 0.7; }

        .world-info { text-align: left; flex: 1; }
        .world-name { font-size: 10px; color: #fff; margin-bottom: 6px; }
        .world-meta { font-size: 7px; color: #aaa; }

        .slot-actions { display: flex; gap: 8px; }

        .btn-mini { padding: 8px; font-size: 8px; background: #5b8a3e; border: 3px solid; border-color: #92c47c #2d451f #2d451f #92c47c; color: #fff; cursor: pointer; }
        .btn-mini.red { background: #b71c1c; border-color: #ef5350 #7f0000 #7f0000 #ef5350; }
        .btn-mini:hover { filter: brightness(1.2); }

        .hud-anchor {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: none;
            z-index: 50;
        }

        .hotbar-hud { display: flex; background: rgba(0, 0, 0, 0.6); padding: 4px; border: 4px solid #1a1a1a; pointer-events: auto; }
        .hud-slot { width: 52px; height: 52px; border: 4px solid transparent; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.05); position: relative; cursor: crosshair; }
        .hud-slot.active { border-color: #fff; background: rgba(255, 255, 255, 0.25); box-shadow: inset 0 0 10px rgba(255,255,255,0.5); }

        #inventory-screen { position: absolute; inset: 0; background: rgba(0, 0, 0, 0.7); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
        .mc-container { background: #c6c6c6; border: 6px solid; border-color: #eee #444 #444 #eee; padding: 20px; box-shadow: 8px 8px 0 rgba(0,0,0,0.6); display: flex; flex-direction: column; gap: 15px; position: relative; width: 600px; }
        .mc-label { color: #222; font-size: 9px; margin-bottom: 6px; font-weight: bold; }
        .mc-slot { width: 48px; height: 48px; background: #8b8b8b; border: 4px solid; border-color: #373737 #fefefe #fefefe #373737; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; }
        .mc-slot:hover { background: #aaa; box-shadow: inset 0 0 0 2px rgba(255,255,255,0.3); }
        .mc-slot.output { width: 56px; height: 56px; border-width: 5px; }
        .mc-grid { display: grid; gap: 4px; }
        #main-inventory-grid { max-height: 220px; overflow-y: auto; padding: 2px; }
        .top-section { display: flex; gap: 40px; align-items: flex-start; }
        .crafting-section { display: flex; align-items: center; gap: 20px; }
        .crafting-grid-2x2 { display: grid; grid-template-columns: repeat(2, 48px); gap: 4px; }
        .crafting-grid-3x3 { display: grid; grid-template-columns: repeat(3, 48px); gap: 4px; }
        .arrow-right { width: 34px; height: 24px; background: #444; clip-path: polygon(0% 20%, 60% 20%, 60% 0%, 100% 50%, 60% 100%, 60% 80%, 0% 80%); }
        .block-icon { width: 34px; height: 34px; pointer-events: none; position: relative; display: flex; align-items: center; justify-content: center; }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 11px; color: #fff; text-shadow: 2px 2px #000; font-weight: bold; pointer-events: none; z-index: 10; }
        #held-item-cursor { position: fixed; pointer-events: none; z-index: 1000; display: none; filter: drop-shadow(4px 4px 2px rgba(0,0,0,0.5)); }
        
        /* Tooltip Style */
        #item-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(16, 0, 16, 0.9);
            border: 2px solid #2d0a63;
            color: #fff;
            padding: 6px 10px;
            font-size: 8px;
            z-index: 2000;
            display: none;
            white-space: nowrap;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
            line-height: 1.2;
        }

        .status-ui { position: absolute; top: 25px; left: 25px; display: flex; flex-direction: column; gap: 12px; }
        .hearts { display: flex; gap: 6px; pointer-events: none; }
        .heart { width: 22px; height: 22px; background: #ff4d4d; border: 3px solid #7a0000; box-shadow: 3px 3px 0 rgba(0,0,0,0.3); border-radius: 4px; }
        .heart.empty { background: #222; border-color: #000; box-shadow: none; }
        #death-screen { position: absolute; inset: 0; background: rgba(30,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 101; }
        .btn { margin-top: 15px; padding: 15px 30px; background: #5b8a3e; border: 6px solid; border-color: #92c47c #2d451f #2d451f #92c47c; color: #fff; cursor: pointer; font-size: 12px; pointer-events: auto; text-align: center; box-shadow: 6px 6px 0 rgba(0,0,0,0.4); z-index: 10; transition: transform 0.1s; }
        .btn:hover { background: #6da34a; transform: scale(1.05); }
        .btn.grey { background: #888; border-color: #bbb #444 #444 #bbb; }
        .btn.gold { background: #f1c40f; border-color: #f9e79f #b8860b #b8860b #f9e79f; color: #333; }
        #portal-overlay {
            position: absolute;
            inset: 0;
            background: #4a148c;
            opacity: 0;
            z-index: 300;
            pointer-events: none;
            transition: opacity 1s;
        }
        #save-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            font-size: 8px;
            color: #76b052;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="portal-overlay"></div>
        <div id="held-item-cursor"></div>
        <div id="item-tooltip"></div>
        <div id="save-indicator">SAVING...</div>
        
        <div id="mode-selection-overlay">
            <h2 style="font-size: 20px; color: #fff; margin-bottom: 30px; text-shadow: 4px 4px #000;">SELECT GAME MODE</h2>
            <div style="display: flex; gap: 20px;">
                <div style="flex: 1; text-align: center;">
                    <div class="btn" style="width: 200px;" onclick="confirmNewWorld('survival')">SURVIVAL</div>
                    <div style="font-size: 7px; color: #aaa; margin-top: 10px; line-height: 1.5;">Limited life.<br>Mine for resources.<br>Hunger and danger!</div>
                </div>
                <div style="flex: 1; text-align: center;">
                    <div class="btn gold" style="width: 200px;" onclick="confirmNewWorld('creative')">CREATIVE</div>
                    <div style="font-size: 7px; color: #f1c40f; margin-top: 10px; line-height: 1.5;">Invincibility.<br>Double jump to fly.<br>Infinite blocks!</div>
                </div>
            </div>
            <div class="btn grey" style="margin-top: 40px; padding: 10px 20px;" onclick="closeModeSelection()">CANCEL</div>
        </div>

        <div id="pause-menu">
            <h2 style="font-size: 24px; color: #fff; margin-bottom: 30px; text-shadow: 4px 4px #000;">GAME PAUSED</h2>
            <div class="btn" onclick="togglePauseMenu()">RESUME</div>
            <div class="btn grey" onclick="saveAndQuit()">SAVE AND QUIT</div>
        </div>

        <div id="title-screen">
            <div class="floating-numbers" id="floating-numbers"></div>
            <div class="hero-scene">
                <div class="title-pig"></div>
                <div class="title-clock"></div>
            </div>
            <h1 class="game-title">MOINK <span>O'CLOCK</span></h1>
            
            <div class="mc-label" style="color: #aaa; font-size: 10px; margin-bottom: 5px;">SELECT WORLD</div>
            <div class="worlds-container" id="worlds-container">
                <div class="world-slot empty" id="slot-0">
                    <div class="world-info">
                        <div class="world-name">SLOT 1</div>
                        <div class="world-meta">EMPTY WORLD</div>
                    </div>
                    <div class="slot-actions">
                        <button class="btn-mini" onclick="handleSlotAction(0, 'play')">NEW</button>
                    </div>
                </div>
                <div class="world-slot empty" id="slot-1">
                    <div class="world-info">
                        <div class="world-name">SLOT 2</div>
                        <div class="world-meta">EMPTY WORLD</div>
                    </div>
                    <div class="slot-actions">
                        <button class="btn-mini" onclick="handleSlotAction(1, 'play')">NEW</button>
                    </div>
                </div>
                <div class="world-slot empty" id="slot-2">
                    <div class="world-info">
                        <div class="world-name">SLOT 3</div>
                        <div class="world-meta">EMPTY WORLD</div>
                    </div>
                    <div class="slot-actions">
                        <button class="btn-mini" onclick="handleSlotAction(2, 'play')">NEW</button>
                    </div>
                </div>
            </div>

            <div style="font-size: 6px; color: #555; margin-top: 20px;">ESC: PAUSE | WASD: MOVE | SPACE: JUMP | E: INV</div>
        </div>
        <div class="ui-overlay">
            <div class="status-ui">
                <div id="coords" style="font-size: 10px; color: #fff; text-shadow: 2px 2px #000;">X: 0 Y: 0</div>
                <div id="dim-indicator" style="font-size: 10px; color: #ffb6c1; text-shadow: 2px 2px #000;">Overworld</div>
                <div id="mode-indicator" style="font-size: 7px; color: #aaa;">Survival Mode</div>
            </div>
            <div class="hud-anchor">
                <div class="hearts" id="hearts-container"></div>
                <div class="hotbar-hud" id="hotbar-hud"></div>
            </div>
        </div>
        <div id="inventory-screen">
            <div class="mc-container" id="mc-inventory">
                <div class="top-section">
                    <div id="pig-preview" style="width: 100px; height: 120px; background: #8b8b8b; border: 4px solid #373737; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;">
                        <span style="font-size: 8px; color: #444; font-weight: bold;">PIGGY</span>
                        <div style="position: absolute; width: 40px; height: 30px; background: #ffb6c1; border: 2px solid #ff69b4; border-radius: 2px;">
                           <div style="position: absolute; right: 2px; top: 4px; width: 4px; height: 4px; background: #000;"></div>
                        </div>
                    </div>
                    <div>
                        <div class="mc-label" id="crafting-label">Crafting</div>
                        <div class="crafting-section">
                            <div class="crafting-grid-2x2" id="crafting-grid-2x2">
                                <div class="mc-slot" data-type="craft2" data-idx="0"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="1"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="2"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="3"></div>
                            </div>
                            <div class="crafting-grid-3x3" id="crafting-grid-3x3" style="display: none;">
                                <div class="mc-slot" data-type="craft3" data-idx="0"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="1"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="2"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="3"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="4"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="5"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="6"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="7"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="8"></div>
                            </div>
                            <div class="arrow-right"></div>
                            <div class="mc-slot output" id="crafting-output"></div>
                        </div>
                    </div>
                </div>
                <div>
                    <div class="mc-label" id="inventory-label">Inventory</div>
                    <div class="mc-grid" style="grid-template-columns: repeat(9, 48px);" id="main-inventory-grid"></div>
                </div>
                <div style="margin-top: 8px;">
                    <div class="mc-grid" style="grid-template-columns: repeat(9, 48px);" id="hotbar-inventory-grid"></div>
                </div>
            </div>
        </div>
        <div id="death-screen">
            <h1 style="color: #ff4d4d; font-size: 24px; margin-bottom: 25px; text-shadow: 4px 4px #000;">YOU FAILED THE OINK</h1>
            <div class="btn" onclick="respawn()">START NEW CYCLE</div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 40;
        const GRAVITY = 0.45;
        const FRICTION = 0.8;
        const SPEED = 0.5;
        const SPRINT_SPEED = 0.9;
        const JUMP = -10;
        const MAX_HEALTH = 10;
        const INVULN_TIME = 45;
        const WORLD_WIDTH = 100;
        const WORLD_HEIGHT = 100;

        const BLOCK_TYPES = {
            1: { name: 'Grass', color: '#5b8a3e', stroke: '#3e5b2e', hardness: 10, tool: 'shovel', topColor: '#76b052' },
            2: { name: 'Dirt', color: '#7a5a3a', stroke: '#4d3a24', hardness: 12, tool: 'shovel' },
            3: { name: 'Stone', color: '#828282', stroke: '#555555', hardness: 50, tool: 'pickaxe', texture: 'stone' },
            4: { name: 'Wood', color: '#6d4c41', stroke: '#3e2723', hardness: 30, tool: 'axe' },
            5: { name: 'Leaves', color: '#2e7d32', stroke: '#1b5e20', hardness: 5 },
            6: { name: 'Lava', color: '#ff5722', stroke: '#bf360c', hazard: true, hardness: 1000, animated: true },
            7: { name: 'Cobble', color: '#616161', stroke: '#424242', hardness: 45, tool: 'pickaxe', texture: 'cobble' },
            8: { name: 'Sand', color: '#ffecb3', stroke: '#ffe082', hardness: 10, tool: 'shovel' },
            10: { name: 'Planks', color: '#d2b48c', stroke: '#8b4513', hardness: 25, tool: 'axe' },
            11: { name: 'Clock', color: '#fdd835', stroke: '#f9a825', special: true, hardness: 80, tool: 'pickaxe' },
            12: { name: 'Crafting Table', color: '#795548', stroke: '#3e2723', hardness: 40, table: true, tool: 'axe' },
            13: { name: 'Coal Ore', color: '#828282', stroke: '#555555', hardness: 55, ore: '#212121', tool: 'pickaxe', drop: 30 },
            14: { name: 'Iron Ore', color: '#828282', stroke: '#555555', hardness: 75, ore: '#d7ccc8', tool: 'pickaxe', drop: 31 },
            15: { name: 'Stick', color: '#5d4037', stroke: '#3e2723', hardness: 10, item: true },
            16: { name: 'Wood Pickaxe', color: '#6d4c41', toolType: 'pickaxe', tier: 1, item: true },
            17: { name: 'Wood Shovel', color: '#6d4c41', toolType: 'shovel', tier: 1, item: true },
            18: { name: 'Wood Axe', color: '#6d4c41', toolType: 'axe', tier: 1, item: true },
            19: { name: 'Stone Pickaxe', color: '#616161', toolType: 'pickaxe', tier: 2, item: true },
            20: { name: 'Stone Shovel', color: '#616161', toolType: 'shovel', tier: 2, item: true },
            21: { name: 'Stone Axe', color: '#616161', toolType: 'axe', tier: 2, item: true },
            22: { name: 'Iron Pickaxe', color: '#e0e0e0', toolType: 'pickaxe', tier: 3, item: true },
            23: { name: 'Iron Shovel', color: '#e0e0e0', toolType: 'shovel', tier: 3, item: true },
            24: { name: 'Iron Axe', color: '#e0e0e0', toolType: 'axe', tier: 3, item: true },
            25: { name: 'Gold Ore', color: '#828282', stroke: '#555555', hardness: 80, ore: '#ffeb3b', tool: 'pickaxe', drop: 32 },
            26: { name: 'Diamond Ore', color: '#828282', stroke: '#555555', hardness: 150, ore: '#80deea', tool: 'pickaxe', drop: 33 },
            27: { name: 'Redstone Ore', color: '#828282', stroke: '#555555', hardness: 70, ore: '#ff1744', tool: 'pickaxe', drop: 34 },
            28: { name: 'Obsidian', color: '#212121', stroke: '#1a1a1a', hardness: 600, tool: 'pickaxe', texture: 'obsidian' },
            29: { name: 'Bedrock', color: '#1a1a1a', stroke: '#000000', hardness: 999999 },
            30: { name: 'Coal', color: '#212121', item: true, type: 'coal' },
            31: { name: 'Iron Ingot', color: '#f5f5f5', stroke: '#bdbdbd', item: true, type: 'ingot' },
            32: { name: 'Gold Ingot', color: '#fff176', stroke: '#fbc02d', item: true, type: 'ingot' },
            33: { name: 'Diamond', color: '#00e5ff', stroke: '#00b8d4', item: true, type: 'gem' },
            34: { name: 'Redstone Dust', color: '#ff1744', item: true, type: 'dust' },
            70: { name: 'Iron Helmet', color: '#f5f5f5', stroke: '#bdbdbd', item: true, type: 'armor', part: 'helm' },
            71: { name: 'Iron Chestplate', color: '#f5f5f5', stroke: '#bdbdbd', item: true, type: 'armor', part: 'chest' },
            72: { name: 'Iron Leggings', color: '#f5f5f5', stroke: '#bdbdbd', item: true, type: 'armor', part: 'legs' },
            73: { name: 'Iron Boots', color: '#f5f5f5', stroke: '#bdbdbd', item: true, type: 'armor', part: 'boots' },
            74: { name: 'Gold Helmet', color: '#fff176', stroke: '#fbc02d', item: true, type: 'armor', part: 'helm' },
            75: { name: 'Gold Chestplate', color: '#fff176', stroke: '#fbc02d', item: true, type: 'armor', part: 'chest' },
            76: { name: 'Gold Leggings', color: '#fff176', stroke: '#fbc02d', item: true, type: 'armor', part: 'legs' },
            77: { name: 'Gold Boots', color: '#fff176', stroke: '#fbc02d', item: true, type: 'armor', part: 'boots' },
            78: { name: 'Diamond Helmet', color: '#00e5ff', stroke: '#00b8d4', item: true, type: 'armor', part: 'helm' },
            79: { name: 'Diamond Chestplate', color: '#00e5ff', stroke: '#00b8d4', item: true, type: 'armor', part: 'chest' },
            80: { name: 'Diamond Leggings', color: '#00e5ff', stroke: '#00b8d4', item: true, type: 'armor', part: 'legs' },
            81: { name: 'Diamond Boots', color: '#00e5ff', stroke: '#00b8d4', item: true, type: 'armor', part: 'boots' },
            51: { name: 'Netherrack', color: '#b71c1c', stroke: '#7f0000', hardness: 15, tool: 'pickaxe', texture: 'netherrack' },
            52: { name: 'Glowstone', color: '#fff59d', stroke: '#fbc02d', hardness: 10, animated: true },
            57: { name: 'Gravel', color: '#bdbdbd', stroke: '#9e9e9e', hardness: 10, tool: 'shovel', dropChance: 0.1, dropId: 58 },
            58: { name: 'Flint', color: '#424242', item: true },
            59: { name: 'Flint and Steel', color: '#e0e0e0', item: true, action: 'ignite' },
            60: { name: 'Nether Portal', color: '#6a1b9a', stroke: '#4a148c', hardness: 999, animated: true, teleport: true },
            61: { name: 'Soul Sand', color: '#5d4037', stroke: '#3e2723', hardness: 15, tool: 'shovel' },
            62: { name: 'Magma', color: '#bf360c', stroke: '#ff5722', hazard: true, hardness: 40, tool: 'pickaxe', animated: true }
        };

        const RECIPES = [
            { pattern: [[4]], result: 10, amount: 4 },
            { pattern: [[10], [10]], result: 15, amount: 4 },
            { pattern: [[10, 10], [10, 10]], result: 12, amount: 1 },
            { pattern: [[7, 7, 7], [null, 15, null], [null, 15, null]], result: 19, amount: 1 },
            { pattern: [[10, 10, 10], [null, 15, null], [null, 15, null]], result: 16, amount: 1 },
            { pattern: [[31, 31, 31], [null, 15, null], [null, 15, null]], result: 22, amount: 1 },
            { pattern: [[10], [15], [15]], result: 17, amount: 1 },
            { pattern: [[7], [15], [15]], result: 20, amount: 1 },
            { pattern: [[31], [15], [15]], result: 23, amount: 1 },
            { pattern: [[10, 10], [10, 15], [null, 15]], result: 18, amount: 1 },
            { pattern: [[7, 7], [7, 15], [null, 15]], result: 21, amount: 1 },
            { pattern: [[31, 31], [31, 15], [null, 15]], result: 24, amount: 1 },
            { pattern: [[null, 32, null], [32, 15, 32], [null, 32, null]], result: 11, amount: 1 },
            { pattern: [[30], [15]], result: 1, amount: 1 }, 
            { pattern: [[58, 31]], result: 59, amount: 1 },
            { pattern: [[31, 31, 31], [31, null, 31]], result: 70, amount: 1 },
            { pattern: [[31, null, 31], [31, 31, 31], [31, 31, 31]], result: 71, amount: 1 },
            { pattern: [[31, 31, 31], [31, null, 31], [31, null, 31]], result: 72, amount: 1 },
            { pattern: [[31, null, 31], [31, null, 31]], result: 73, amount: 1 },
            { pattern: [[32, 32, 32], [32, null, 32]], result: 74, amount: 1 },
            { pattern: [[32, null, 32], [32, 32, 32], [32, 32, 32]], result: 75, amount: 1 },
            { pattern: [[32, 32, 32], [32, null, 32], [32, null, 32]], result: 76, amount: 1 },
            { pattern: [[32, null, 32], [32, null, 32]], result: 77, amount: 1 },
            { pattern: [[33, 33, 33], [33, null, 33]], result: 78, amount: 1 },
            { pattern: [[33, null, 33], [33, 33, 33], [33, 33, 33]], result: 79, amount: 1 },
            { pattern: [[33, 33, 33], [33, null, 33], [33, null, 33]], result: 80, amount: 1 },
            { pattern: [[33, null, 33], [33, null, 33]], result: 81, amount: 1 }
        ];

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const heartsContainer = document.getElementById('hearts-container');
        const portalOverlay = document.getElementById('portal-overlay');
        const saveIndicator = document.getElementById('save-indicator');
        const pauseMenuEl = document.getElementById('pause-menu');
        const modeSelectionEl = document.getElementById('mode-selection-overlay');
        const itemTooltipEl = document.getElementById('item-tooltip');
        
        let width, height;
        let camera = { x: 0, y: 0 };
        let currentDimension = 'overworld';
        let worlds = { overworld: {}, nether: {} };
        let teleportTimer = 0;
        let activeSaveSlot = null;
        let pendingSaveSlot = null;
        
        let player = { 
            x: (WORLD_WIDTH / 2) * TILE_SIZE, 
            y: 0, 
            vx: 0, 
            vy: 0, 
            w: 34, 
            h: 28, 
            grounded: false, 
            health: MAX_HEALTH, 
            invuln: 0, 
            dead: false, 
            facing: 1,
            animTimer: 0,
            squash: 1,
            gameMode: 'survival', 
            isFlying: false,
            lastJumpTime: 0
        };
        
        let mainInventory = new Array(27).fill(null);
        let hotbarInventory = new Array(9).fill(null);
        let craftingGrid2x2 = new Array(4).fill(null);
        let craftingGrid3x3 = new Array(9).fill(null);
        let craftingOutput = null;
        let activeRecipeMatch = null;
        let heldItem = null;

        let isUsingTable = false;
        let miningTarget = null;
        let miningProgress = 0;
        let activeHotbarIndex = 0; 
        let inventoryOpen = false;
        let isPaused = false;
        let gameStarted = false;
        let keys = {};
        let mouse = { x: 0, y: 0, down: false, rightDown: false };
        let particles = [];

        function init() {
            resize();
            updateSlotsUI();
            setupInventoryUI();
            setupTitleParticles();

            window.addEventListener('resize', resize);
            window.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                if (!gameStarted) {
                    keys[key] = true;
                    return;
                }

                if (e.key === 'Escape') {
                    if (inventoryOpen) toggleInventory();
                    else togglePauseMenu();
                }

                if (!isPaused) {
                    if (key === 'e') toggleInventory();
                    if (!inventoryOpen && e.key >= '1' && e.key <= '9') { activeHotbarIndex = parseInt(e.key) - 1; updateHUD(); }
                    
                    if (!inventoryOpen && (key === 'w' || key === ' ')) {
                        const now = Date.now();
                        if (player.gameMode === 'creative' && now - player.lastJumpTime < 300) {
                            player.isFlying = !player.isFlying;
                            player.vy = 0;
                        }
                        player.lastJumpTime = now;
                    }
                }
                keys[key] = true;
            });
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            window.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
                if (gameStarted) {
                    updateHeldItemCursor();
                    updateTooltip();
                }
            });
            window.addEventListener('mousedown', e => {
                if (!gameStarted || isPaused) return;
                if (e.button === 0) mouse.down = true;
                if (e.button === 2) { mouse.rightDown = true; if (!inventoryOpen) handleWorldInteraction(); }
            });
            window.addEventListener('mouseup', e => { if (e.button === 0) mouse.down = false; if (e.button === 2) mouse.rightDown = false; });
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            requestAnimationFrame(loop);
        }

        function togglePauseMenu() {
            if (player.dead) return;
            isPaused = !isPaused;
            pauseMenuEl.style.display = isPaused ? 'flex' : 'none';
        }

        function saveAndQuit() {
            saveGame();
            isPaused = false;
            gameStarted = false;
            pauseMenuEl.style.display = 'none';
            document.getElementById('title-screen').style.display = 'flex';
            updateSlotsUI();
        }

        function updateSlotsUI() {
            for (let i = 0; i < 3; i++) {
                const slotEl = document.getElementById(`slot-${i}`);
                const data = localStorage.getItem(`moinkcraft_world_${i}`);
                if (data) {
                    const parsed = JSON.parse(data);
                    slotEl.className = 'world-slot';
                    slotEl.querySelector('.world-meta').innerText = `SAVED: ${parsed.timestamp || 'N/A'}`;
                    slotEl.querySelector('.slot-actions').innerHTML = `
                        <button class="btn-mini" onclick="handleSlotAction(${i}, 'play')">PLAY</button>
                        <button class="btn-mini red" onclick="handleSlotAction(${i}, 'delete')">X</button>
                    `;
                } else {
                    slotEl.className = 'world-slot empty';
                    slotEl.querySelector('.world-meta').innerText = 'EMPTY WORLD';
                    slotEl.querySelector('.slot-actions').innerHTML = `
                        <button class="btn-mini" onclick="handleSlotAction(${i}, 'play')">NEW</button>
                    `;
                }
            }
        }

        function handleSlotAction(slot, action) {
            if (action === 'play') {
                const data = localStorage.getItem(`moinkcraft_world_${slot}`);
                if (data) {
                    activeSaveSlot = slot;
                    loadGame(JSON.parse(data));
                    startGame();
                } else {
                    pendingSaveSlot = slot;
                    modeSelectionEl.style.display = 'flex';
                }
            } else if (action === 'delete') {
                if (confirm('DELETE WORLD FOREVER?')) {
                    localStorage.removeItem(`moinkcraft_world_${slot}`);
                    updateSlotsUI();
                }
            }
        }

        function closeModeSelection() {
            modeSelectionEl.style.display = 'none';
            pendingSaveSlot = null;
        }

        function confirmNewWorld(mode) {
            activeSaveSlot = pendingSaveSlot;
            pendingSaveSlot = null;
            modeSelectionEl.style.display = 'none';
            startNewWorld(mode);
            startGame();
        }

        function saveGame() {
            if (activeSaveSlot === null || player.dead) return;
            const saveData = {
                worlds: worlds,
                player: {
                    x: player.x,
                    y: player.y,
                    health: player.health,
                    dimension: currentDimension,
                    gameMode: player.gameMode
                },
                inventory: {
                    main: mainInventory,
                    hotbar: hotbarInventory
                },
                timestamp: new Date().toLocaleString()
            };
            localStorage.setItem(`moinkcraft_world_${activeSaveSlot}`, JSON.stringify(saveData));
            showSaveIndicator();
        }

        function loadGame(data) {
            worlds = data.worlds;
            player.x = data.player.x;
            player.y = data.player.y;
            player.health = data.player.health;
            player.gameMode = data.player.gameMode || 'survival';
            currentDimension = data.player.dimension || 'overworld';
            mainInventory = data.inventory.main;
            hotbarInventory = data.inventory.hotbar;
            player.isFlying = false;
            updateHUD();
            updateHeartsUI();
        }

        function startNewWorld(mode = 'survival') {
            worlds = { overworld: {}, nether: {} };
            generateOverworld();
            generateNether();
            mainInventory = new Array(27).fill(null);
            hotbarInventory = new Array(9).fill(null);
            
            const startX = Math.floor(WORLD_WIDTH / 2);
            let startY = 0;
            const world = worlds.overworld;
            while(!world[`${startX},${startY}`] && startY < WORLD_HEIGHT) startY++;
            player.x = startX * TILE_SIZE;
            player.y = (startY - 2) * TILE_SIZE;
            player.health = MAX_HEALTH;
            player.gameMode = mode;
            player.isFlying = false;
            currentDimension = 'overworld';
            updateHUD();
            updateHeartsUI();
            saveGame();
        }

        function showSaveIndicator() {
            saveIndicator.style.opacity = '1';
            setTimeout(() => { saveIndicator.style.opacity = '0'; }, 2000);
        }

        function createParticles(x, y, color, count = 5) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: -Math.random() * 5,
                    color,
                    life: 30 + Math.random() * 20
                });
            }
        }

        function setupTitleParticles() {
            const container = document.getElementById('floating-numbers');
            for(let i=0; i<15; i++) {
                const p = document.createElement('div');
                p.className = 'time-particle';
                p.innerText = Math.floor(Math.random() * 12) + 1;
                p.style.left = Math.random() * 100 + 'vw';
                p.style.animationDelay = (Math.random() * 10) + 's';
                p.style.fontSize = (Math.random() * 20 + 20) + 'px';
                container.appendChild(p);
            }
        }

        function startGame() { gameStarted = true; isPaused = false; document.getElementById('title-screen').style.display = 'none'; }
        function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }

        function toggleInventory(useTable = false) {
            if (isPaused) return;
            inventoryOpen = !inventoryOpen;
            isUsingTable = useTable;
            const screen = document.getElementById('inventory-screen');
            screen.style.display = inventoryOpen ? 'flex' : 'none';
            document.getElementById('crafting-grid-2x2').style.display = (isUsingTable || player.gameMode === 'creative') ? 'none' : 'grid';
            document.getElementById('crafting-grid-3x3').style.display = isUsingTable ? 'grid' : 'none';
            document.getElementById('pig-preview').style.display = (isUsingTable || player.gameMode === 'creative') ? 'none' : 'flex';
            
            const craftingLabel = document.getElementById('crafting-label');
            const invLabel = document.getElementById('inventory-label');
            
            if (player.gameMode === 'creative') {
                craftingLabel.innerText = "Item Palette";
                invLabel.innerText = "Creative Palette (Click to take)";
                document.querySelector('.top-section').style.display = 'none';
            } else {
                document.querySelector('.top-section').style.display = 'flex';
                craftingLabel.innerText = isUsingTable ? 'Crafting Table' : 'Crafting';
                invLabel.innerText = "Inventory";
            }

            if (!inventoryOpen) {
                const returnItems = (grid) => { grid.forEach((item, i) => { if (item) addItemToInventory(item.id, item.count); grid[i] = null; }); };
                returnItems(craftingGrid2x2); returnItems(craftingGrid3x3);
                if (heldItem && player.gameMode !== 'creative') { addItemToInventory(heldItem.id, heldItem.count); heldItem = null; }
                else if (heldItem) { heldItem = null; }
                updateHeldItemCursor();
                saveGame();
            }
            itemTooltipEl.style.display = 'none';
            renderInventory();
        }

        function setupInventoryUI() {
            const setupSlot = (slot) => {
                slot.addEventListener('mousedown', (e) => {
                    const type = slot.dataset.type;
                    const idx = parseInt(slot.dataset.idx);
                    handleSlotClick(type, idx, e.button);
                    e.preventDefault();
                });
                slot.addEventListener('contextmenu', (e) => e.preventDefault());
            };
            const mainGrid = document.getElementById('main-inventory-grid');
            mainGrid.innerHTML = '';
            for (let i = 0; i < 27; i++) {
                const slot = document.createElement('div');
                slot.className = 'mc-slot';
                slot.dataset.type = 'main'; slot.dataset.idx = i;
                setupSlot(slot);
                mainGrid.appendChild(slot);
            }
            const hbGrid = document.getElementById('hotbar-inventory-grid');
            hbGrid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'mc-slot';
                slot.dataset.type = 'hotbar'; slot.dataset.idx = i;
                setupSlot(slot);
                hbGrid.appendChild(slot);
            }
            document.querySelectorAll('#crafting-grid-2x2 .mc-slot').forEach(setupSlot);
            document.querySelectorAll('#crafting-grid-3x3 .mc-slot').forEach(setupSlot);
            document.getElementById('crafting-output').addEventListener('mousedown', (e) => { if (e.button === 0) handleCraftingOutputClick(); });
        }

        function renderInventory() {
            const mainGrid = document.getElementById('main-inventory-grid');
            
            if (player.gameMode === 'creative') {
                mainGrid.innerHTML = '';
                const allItemIds = Object.keys(BLOCK_TYPES);
                allItemIds.forEach((id, i) => {
                    const slot = document.createElement('div');
                    slot.className = 'mc-slot';
                    slot.dataset.type = 'creative'; 
                    slot.dataset.idx = i;
                    slot.dataset.itemId = id;
                    slot.appendChild(createItemVisual(parseInt(id), 1));
                    slot.addEventListener('mousedown', (e) => {
                        handleSlotClick('creative', parseInt(id), e.button);
                        e.preventDefault();
                    });
                    mainGrid.appendChild(slot);
                });
            } else {
                if (mainGrid.children.length !== 27) {
                    mainGrid.innerHTML = '';
                    for (let i = 0; i < 27; i++) {
                        const slot = document.createElement('div');
                        slot.className = 'mc-slot';
                        slot.dataset.type = 'main'; slot.dataset.idx = i;
                        slot.addEventListener('mousedown', (e) => {
                            handleSlotClick('main', i, e.button);
                            e.preventDefault();
                        });
                        mainGrid.appendChild(slot);
                    }
                }
                const slots = mainGrid.querySelectorAll('.mc-slot');
                mainInventory.forEach((item, i) => { 
                    const slot = slots[i]; 
                    if (!slot) return; 
                    slot.innerHTML = ''; 
                    if (item) slot.appendChild(createItemVisual(item.id, item.count)); 
                });
            }

            const hbGrid = document.getElementById('hotbar-inventory-grid');
            const hbSlots = hbGrid.querySelectorAll('.mc-slot');
            hotbarInventory.forEach((item, i) => { 
                const slot = hbSlots[i]; 
                if (!slot) return; 
                slot.innerHTML = ''; 
                if (item) slot.appendChild(createItemVisual(item.id, item.count)); 
            });

            const craftSlots2 = document.querySelectorAll('#crafting-grid-2x2 .mc-slot');
            craftingGrid2x2.forEach((item, i) => { if(craftSlots2[i]) { craftSlots2[i].innerHTML = ''; if (item) craftSlots2[i].appendChild(createItemVisual(item.id, item.count)); } });
            
            const craftSlots3 = document.querySelectorAll('#crafting-grid-3x3 .mc-slot');
            craftingGrid3x3.forEach((item, i) => { if(craftSlots3[i]) { craftSlots3[i].innerHTML = ''; if (item) craftSlots3[i].appendChild(createItemVisual(item.id, item.count)); } });

            checkRecipes();
            const outputSlot = document.getElementById('crafting-output');
            outputSlot.innerHTML = '';
            if (craftingOutput) outputSlot.appendChild(createItemVisual(craftingOutput.id, craftingOutput.count));
            updateHUD();
        }

        function createItemVisual(id, count) {
            const block = BLOCK_TYPES[id];
            if (!block) return document.createElement('div');
            const container = document.createElement('div');
            container.className = 'block-icon';
            
            const drawShape = (style) => {
                const div = document.createElement('div');
                Object.assign(div.style, style, { position: 'absolute' });
                container.appendChild(div);
            };

            if (block.type === 'ingot') {
                drawShape({ width: '24px', height: '12px', background: block.color, border: `2px solid ${block.stroke}`, transform: 'rotate(-25deg)', borderRadius: '2px', boxShadow: 'inset 2px 2px 0 rgba(255,255,255,0.4)' });
            } else if (block.type === 'coal') {
                drawShape({ width: '18px', height: '18px', background: block.color, clipPath: 'polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)', boxShadow: 'inset 2px 2px 0 rgba(255,255,255,0.1)' });
            } else if (block.type === 'gem') {
                drawShape({ width: '18px', height: '18px', background: block.color, clipPath: 'polygon(50% 0%, 100% 40%, 80% 100%, 20% 100%, 0% 40%)', border: `2px solid ${block.stroke}`, boxShadow: 'inset 0 0 10px rgba(255,255,255,0.5)' });
            } else if (block.type === 'dust') {
                for(let i=0; i<6; i++) {
                    drawShape({ width: '4px', height: '4px', background: block.color, left: (Math.random()*24)+'px', top: (Math.random()*24)+'px', borderRadius: '1px', boxShadow: '0 0 4px '+block.color });
                }
            } else if (block.type === 'armor') {
                const c = block.color;
                const s = `2px solid ${block.stroke}`;
                if (block.part === 'helm') {
                    drawShape({ width: '20px', height: '16px', background: c, border: s, borderRadius: '10px 10px 2px 2px' });
                } else if (block.part === 'chest') {
                    drawShape({ width: '24px', height: '20px', background: c, border: s, borderRadius: '4px' });
                    drawShape({ width: '30px', height: '8px', background: c, border: s, top: '4px', borderRadius: '2px' });
                } else if (block.part === 'legs') {
                    drawShape({ width: '22px', height: '18px', background: c, border: s, clipPath: 'polygon(0% 0%, 100% 0%, 100% 100%, 65% 100%, 65% 35%, 35% 35%, 35% 100%, 0% 100%)' });
                } else if (block.part === 'boots') {
                    drawShape({ width: '10px', height: '10px', background: c, border: s, left: '4px', borderRadius: '2px' });
                    drawShape({ width: '10px', height: '10px', background: c, border: s, right: '4px', borderRadius: '2px' });
                }
            } else if (block.toolType) {
                drawShape({ width: '4px', height: '24px', background: '#5c3b1e', transform: 'rotate(-45deg)' });
                if (block.toolType === 'pickaxe') drawShape({ width: '28px', height: '8px', background: block.color, border: `2px solid ${block.stroke}`, top: '4px', borderRadius: '2px' });
                else if (block.toolType === 'shovel') drawShape({ width: '14px', height: '14px', background: block.color, border: `2px solid ${block.stroke}`, top: '2px', borderRadius: '50%' });
                else if (block.toolType === 'axe') drawShape({ width: '18px', height: '18px', background: block.color, border: `2px solid ${block.stroke}`, top: '2px', left: '4px', borderRadius: '2px 10px 2px 2px' });
            } else if (id === 15) {
                drawShape({ width: '4px', height: '24px', background: '#5c3b1e', transform: 'rotate(-45deg)' });
            } else if (block.item) {
                drawShape({ width: '20px', height: '20px', backgroundColor: block.color, border: `2px solid ${block.stroke}`, borderRadius: '50%' });
            } else {
                drawShape({ width: '30px', height: '30px', backgroundColor: block.color, border: `2px solid ${block.stroke}`, borderRadius: '2px', boxShadow: 'inset 4px 4px 0 rgba(255,255,255,0.2)' });
                if (block.ore) {
                    for(let i=0; i<3; i++) {
                        drawShape({ width: '6px', height: '6px', background: block.ore, left: (Math.random()*20)+'px', top: (Math.random()*20)+'px', borderRadius: '1px' });
                    }
                }
            }

            if (count > 1) { 
                const cnt = document.createElement('div'); 
                cnt.className = 'item-count'; 
                cnt.innerText = count; 
                container.appendChild(cnt); 
            }
            return container;
        }

        function handleSlotClick(type, idx, button) {
            if (type === 'creative') {
                const itemId = idx;
                const block = BLOCK_TYPES[itemId];
                const stackSize = (block.item || block.toolType || block.type === 'armor') ? 1 : 64;
                if (button === 0) {
                    heldItem = { id: itemId, count: stackSize };
                } else {
                    heldItem = { id: itemId, count: 1 };
                }
                updateHeldItemCursor();
                return;
            }

            let targetArray;
            if (type === 'main') targetArray = mainInventory;
            else if (type === 'hotbar') targetArray = hotbarInventory;
            else if (type === 'craft2') targetArray = craftingGrid2x2;
            else if (type === 'craft3') targetArray = craftingGrid3x3;
            if (!targetArray) return;

            if (player.gameMode === 'creative' && type === 'main') return; 

            const current = targetArray[idx];
            
            if (button === 0) {
                if (!heldItem && current) { heldItem = { ...current }; targetArray[idx] = null; }
                else if (heldItem && !current) { targetArray[idx] = { ...heldItem }; heldItem = null; }
                else if (heldItem && current) { 
                    if (heldItem.id === current.id) { current.count += heldItem.count; heldItem = null; }
                    else { const temp = { ...current }; targetArray[idx] = { ...heldItem }; heldItem = temp; } 
                }
            } else if (button === 2) {
                if (heldItem) { 
                    if (!current) { targetArray[idx] = { id: heldItem.id, count: 1 }; heldItem.count--; }
                    else if (current.id === heldItem.id) { current.count++; heldItem.count--; } 
                    if (heldItem.count <= 0) heldItem = null; 
                }
                else if (current) { 
                    const take = Math.ceil(current.count / 2); 
                    heldItem = { id: current.id, count: take }; 
                    current.count -= take; 
                    if (current.count <= 0) targetArray[idx] = null; 
                }
            }
            updateHeldItemCursor(); 
            renderInventory();
        }

        function handleCraftingOutputClick() {
            if (craftingOutput && activeRecipeMatch && (!heldItem || heldItem.id === craftingOutput.id)) {
                if (!heldItem) heldItem = { ...craftingOutput }; else heldItem.count += craftingOutput.count;
                const grid = isUsingTable ? craftingGrid3x3 : craftingGrid2x2;
                const match = activeRecipeMatch;
                const recipe = match.recipe;
                const offsetX = match.offsetX;
                const offsetY = match.offsetY;
                const gridWidth = isUsingTable ? 3 : 2;
                for (let r = 0; r < recipe.pattern.length; r++) {
                    for (let c = 0; c < recipe.pattern[r].length; c++) {
                        const ingId = recipe.pattern[r][c];
                        if (ingId !== null) {
                            const gridIdx = (r + offsetY) * gridWidth + (c + offsetX);
                            grid[gridIdx].count--;
                            if (grid[gridIdx].count <= 0) grid[gridIdx] = null;
                        }
                    }
                }
                renderInventory();
            }
        }

        function checkRecipes() {
            const grid = isUsingTable ? craftingGrid3x3 : craftingGrid2x2;
            const gridWidth = isUsingTable ? 3 : 2;
            const gridHeight = isUsingTable ? 3 : 2;
            let minX = gridWidth, maxX = -1, minY = gridHeight, maxY = -1;
            let totalItemsInGrid = 0;
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const item = grid[y * gridWidth + x];
                    if (item) {
                        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                        totalItemsInGrid++;
                    }
                }
            }
            if (totalItemsInGrid === 0) { craftingOutput = null; activeRecipeMatch = null; return; }
            const subWidth = maxX - minX + 1;
            const subHeight = maxY - minY + 1;
            const subGrid = [];
            for (let y = 0; y < subHeight; y++) {
                subGrid[y] = [];
                for (let x = 0; x < subWidth; x++) {
                    const item = grid[(y + minY) * gridWidth + (x + minX)];
                    subGrid[y][x] = item ? item.id : null;
                }
            }
            let bestMatch = null;
            for (const recipe of RECIPES) {
                const p = recipe.pattern;
                const pHeight = p.length;
                const pWidth = p[0].length;
                if (subWidth !== pWidth || subHeight !== pHeight) continue;
                let matches = true;
                for (let r = 0; r < pHeight; r++) {
                    for (let c = 0; c < pWidth; c++) {
                        if (subGrid[r][c] !== p[r][c]) { matches = false; break; }
                    }
                    if (!matches) break;
                }
                if (matches) { bestMatch = { recipe: recipe, offsetX: minX, offsetY: minY }; break; }
            }
            if (bestMatch) {
                craftingOutput = { id: bestMatch.recipe.result, count: bestMatch.recipe.amount };
                activeRecipeMatch = bestMatch;
            } else {
                craftingOutput = null; activeRecipeMatch = null;
            }
        }

        function updateHeldItemCursor() {
            const cursor = document.getElementById('held-item-cursor');
            if (heldItem) { 
                cursor.style.display = 'block'; 
                cursor.style.left = (mouse.x + 12) + 'px'; 
                cursor.style.top = (mouse.y + 12) + 'px'; 
                cursor.innerHTML = ''; 
                cursor.appendChild(createItemVisual(heldItem.id, heldItem.count)); 
            }
            else { cursor.style.display = 'none'; }
        }

        function updateTooltip() {
            let tooltipText = "";
            const isHoveringElement = (selector) => {
                const el = document.elementFromPoint(mouse.x, mouse.y);
                return el && el.closest(selector);
            };

            const inventorySlot = isHoveringElement('.mc-slot');
            const hudSlot = isHoveringElement('.hud-slot');

            if (inventorySlot) {
                const type = inventorySlot.dataset.type;
                const idx = parseInt(inventorySlot.dataset.idx);
                let item = null;
                if (type === 'main') item = mainInventory[idx];
                else if (type === 'hotbar') item = hotbarInventory[idx];
                else if (type === 'craft2') item = craftingGrid2x2[idx];
                else if (type === 'craft3') item = craftingGrid3x3[idx];
                else if (type === 'creative') {
                    const itemId = parseInt(inventorySlot.dataset.itemId);
                    item = { id: itemId };
                } else if (inventorySlot.id === 'crafting-output') item = craftingOutput;

                if (item) tooltipText = BLOCK_TYPES[item.id]?.name || "";
            } else if (hudSlot) {
                const slots = Array.from(document.querySelectorAll('.hud-slot'));
                const idx = slots.indexOf(hudSlot);
                const item = hotbarInventory[idx];
                if (item) tooltipText = BLOCK_TYPES[item.id]?.name || "";
            } else if (!inventoryOpen && !isPaused) {
                const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
                const wy = Math.floor((mouse.y + camera.y) / TILE_SIZE);
                const blockId = worlds[currentDimension][`${wx},${wy}`];
                if (blockId) tooltipText = BLOCK_TYPES[blockId]?.name || "";
            }

            if (tooltipText) {
                itemTooltipEl.innerText = tooltipText;
                itemTooltipEl.style.display = 'block';
                itemTooltipEl.style.left = (mouse.x + 20) + 'px';
                itemTooltipEl.style.top = (mouse.y - 30) + 'px';
            } else {
                itemTooltipEl.style.display = 'none';
            }
        }

        function addItemToInventory(id, count) {
            const lists = [hotbarInventory, mainInventory];
            for (const list of lists) { 
                for (let i = 0; i < list.length; i++) { 
                    if (list[i] && list[i].id === id) { list[i].count += count; return true; } 
                } 
            }
            for (const list of lists) { 
                for (let i = 0; i < list.length; i++) { 
                    if (!list[i]) { list[i] = { id, count }; return true; } 
                } 
            }
            return false;
        }

        function handleWorldInteraction() {
            if (player.dead || inventoryOpen || isPaused) return;
            const world = worlds[currentDimension];
            const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
            const wy = Math.floor((mouse.y + camera.y) / TILE_SIZE);
            if (wx < 0 || wx >= WORLD_WIDTH || wy < 0 || wy >= WORLD_HEIGHT) return;
            const key = `${wx},${wy}`;
            
            if (mouse.rightDown) {
                const activeItem = hotbarInventory[activeHotbarIndex];
                if (activeItem && activeItem.id === 59) { 
                    if (world[key] === 28) tryIgnitePortal(wx, wy);
                    return;
                }
                if (world[key]) { if (BLOCK_TYPES[world[key]].table) { toggleInventory(true); return; } }
                if (activeItem && !world[key] && !BLOCK_TYPES[activeItem.id].item) {
                    const rect = { x: wx * TILE_SIZE, y: wy * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE };
                    if (!checkOverlap(player, rect)) { 
                        world[key] = activeItem.id;
                        if (player.gameMode !== 'creative') {
                            activeItem.count--; 
                            if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; 
                        }
                        updateHUD(); 
                    }
                }
            }
        }

        function tryIgnitePortal(wx, wy) {
            const world = worlds[currentDimension];
            for(let sx = wx - 4; sx <= wx + 4; sx++) {
                for(let sy = wy - 5; sy <= wy + 5; sy++) {
                    if(world[`${sx},${sy}`] === 28 && world[`${sx+3},${sy}`] === 28) {
                        let isFrame = true;
                        for(let x=0; x<4; x++) if(world[`${sx+x},${sy}`] !== 28 || world[`${sx+x},${sy+4}`] !== 28) isFrame = false;
                        for(let y=0; y<5; y++) if(world[`${sx},${sy+y}`] !== 28 || world[`${sx+3},${sy+y}`] !== 28) isFrame = false;
                        if(isFrame) {
                            for(let x=1; x<=2; x++) for(let y=1; y<=3; y++) world[`${sx+x},${sy+y}`] = 60;
                            createParticles((sx+1.5)*TILE_SIZE, (sy+2)*TILE_SIZE, '#6a1b9a', 20);
                            return;
                        }
                    }
                }
            }
        }

        function updateHUD() {
            const hud = document.getElementById('hotbar-hud');
            hud.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const item = hotbarInventory[i];
                const slot = document.createElement('div');
                slot.className = `hud-slot ${activeHotbarIndex === i ? 'active' : ''}`;
                if (item) slot.appendChild(createItemVisual(item.id, item.count));
                hud.appendChild(slot);
            }
            document.getElementById('dim-indicator').innerText = currentDimension === 'overworld' ? 'Overworld' : 'The Nether';
            document.getElementById('dim-indicator').style.color = currentDimension === 'overworld' ? '#ffb6c1' : '#ff4d4d';
            
            const modeInd = document.getElementById('mode-indicator');
            modeInd.innerText = player.gameMode === 'creative' ? 'Creative Mode' : 'Survival Mode';
            modeInd.style.color = player.gameMode === 'creative' ? '#f1c40f' : '#aaa';
            
            heartsContainer.style.display = player.gameMode === 'creative' ? 'none' : 'flex';
        }

        function updateHeartsUI() { 
            heartsContainer.innerHTML = ''; 
            for(let i=0; i<MAX_HEALTH; i++) { 
                const heart = document.createElement('div'); 
                heart.className = `heart ${i >= player.health ? 'empty' : ''}`; 
                heartsContainer.appendChild(heart); 
            } 
        }

        function generateOverworld() {
            const world = worlds.overworld;
            const surfaceHeights = [];
            const seed = Math.random() * 1000;
            const roughness = 0.05;
            const amplitude = 8;
            const baseHeight = 40;
            for (let x = 0; x < WORLD_WIDTH; x++) {
                const surfaceY = Math.floor(Math.sin(x * roughness + seed) * amplitude + baseHeight);
                surfaceHeights[x] = surfaceY;
                for (let y = surfaceY; y < WORLD_HEIGHT; y++) {
                    let type = 2; if (y === surfaceY) type = 1;
                    if (y === WORLD_HEIGHT - 1) type = 29; 
                    else if (y > surfaceY + 8) {
                        type = 3; 
                        if (y > surfaceY + 12 && Math.random() < 0.1) type = 13;
                        if (Math.random() < 0.05) type = 57; 
                        if (y > surfaceY + 20 && Math.random() < 0.06) type = 14;
                        if (y > surfaceY + 30 && Math.random() < 0.05) type = 27;
                        if (y > surfaceY + 40 && Math.random() < 0.03) type = 25;
                        if (y > surfaceY + 50 && Math.random() < 0.02) type = 26;
                        if (y > surfaceY + 60 && Math.random() < 0.015) type = 28;
                    }
                    if (y > surfaceY + 25 && y < WORLD_HEIGHT - 1 && Math.random() < 0.01) type = 6;
                    world[`${x},${y}`] = type;
                }
            }
            for (let x = 2; x < WORLD_WIDTH - 2; x++) {
                if (Math.random() < 0.1) {
                    const groundY = surfaceHeights[x];
                    if (world[`${x},${groundY}`] === 1) {
                        const th = 4 + Math.floor(Math.random()*2);
                        for (let i=1; i<=th; i++) world[`${x},${groundY-i}`] = 4;
                        for (let lx=-2; lx<=2; lx++) for (let ly=-2; ly<=0; ly++) if(!world[`${x+lx},${groundY-th+ly}`] && Math.abs(lx)+Math.abs(ly) < 4) world[`${x+lx},${groundY-th+ly}`] = 5;
                    }
                }
            }
        }

        function generateNether() {
            const world = worlds.nether;
            const seed = Math.random() * 2000;
            for (let x = 0; x < WORLD_WIDTH; x++) {
                for(let y=0; y<5; y++) world[`${x},${y}`] = 51;
                for(let y=WORLD_HEIGHT-5; y<WORLD_HEIGHT; y++) world[`${x},${y}`] = 51;
                for(let y=WORLD_HEIGHT-10; y<WORLD_HEIGHT-5; y++) world[`${x},${y}`] = 6;
                for (let y = 10; y < WORLD_HEIGHT - 15; y++) {
                    const noise = Math.sin(x * 0.1 + seed) * Math.cos(y * 0.1 + seed);
                    if (noise > 0.4) {
                        let type = 51;
                        if (Math.random() < 0.05) type = 61; 
                        if (Math.random() < 0.02) type = 62; 
                        if (Math.random() < 0.01) type = 52; 
                        world[`${x},${y}`] = type;
                    }
                }
            }
        }

        function checkOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
        
        function takeDamage(amt) { 
            if (player.gameMode === 'creative' || player.invuln > 0 || player.dead) return; 
            player.health -= amt; 
            player.invuln = INVULN_TIME; 
            updateHeartsUI(); 
            if (player.health <= 0) die(); 
            player.vy = -5; 
        }
        
        function die() { 
            player.dead = true; 
            document.getElementById('death-screen').style.display = 'flex'; 
            saveGame(); 
        }
        
        function respawn() { 
            player.health = MAX_HEALTH; player.dead = false; 
            currentDimension = 'overworld'; 
            player.x = (WORLD_WIDTH/2) * TILE_SIZE; player.y = 0;
            const world = worlds[currentDimension];
            let startY = 0;
            while(!world[`${Math.floor(player.x/TILE_SIZE)},${startY}`] && startY < WORLD_HEIGHT) startY++;
            player.y = (startY - 2) * TILE_SIZE;
            player.isFlying = false;
            updateHeartsUI(); updateHUD(); document.getElementById('death-screen').style.display = 'none'; 
            saveGame();
        }

        function getMiningSpeed() {
            if (player.gameMode === 'creative') return 9999;
            const activeItem = hotbarInventory[activeHotbarIndex];
            if (!miningTarget) return 1;
            const world = worlds[currentDimension];
            const targetBlock = world[miningTarget.key];
            if (!targetBlock) return 1;
            const block = BLOCK_TYPES[targetBlock];
            if (block.id === 29) return 0;
            if (!activeItem) return 1;
            const tool = BLOCK_TYPES[activeItem.id];
            if (!tool || !tool.toolType) return 1;
            if (block.tool === tool.toolType) return 1 + (tool.tier * 6);
            return 1;
        }

        function update() {
            if (!gameStarted || player.dead || inventoryOpen || isPaused) return;
            if (player.invuln > 0) player.invuln--;
            
            const world = worlds[currentDimension];

            particles = particles.filter(p => {
                p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life--; return p.life > 0;
            });

            const px = Math.floor((player.x + player.w/2) / TILE_SIZE);
            const py = Math.floor((player.y + player.h/2) / TILE_SIZE);
            if (world[`${px},${py}`] === 60) {
                teleportTimer++;
                portalOverlay.style.opacity = teleportTimer / 60;
                if (teleportTimer >= 60) {
                    currentDimension = currentDimension === 'overworld' ? 'nether' : 'overworld';
                    teleportTimer = 0;
                    portalOverlay.style.opacity = 0;
                    const targetWorld = worlds[currentDimension];
                    let found = false;
                    for(let x=0; x<WORLD_WIDTH && !found; x++) {
                        for(let y=0; y<WORLD_HEIGHT && !found; y++) {
                            if(targetWorld[`${x},${y}`] === 60) {
                                player.x = x * TILE_SIZE; player.y = (y-1) * TILE_SIZE; found = true;
                            }
                        }
                    }
                    if(!found) {
                        player.x = (WORLD_WIDTH/2) * TILE_SIZE;
                        let startY = 0;
                        while(!targetWorld[`${Math.floor(player.x/TILE_SIZE)},${startY}`] && startY < WORLD_HEIGHT) startY++;
                        player.y = (startY - 2) * TILE_SIZE;
                    }
                    updateHUD();
                    saveGame();
                }
            } else {
                teleportTimer = 0;
                portalOverlay.style.opacity = 0;
            }

            if (mouse.down) {
                const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
                const wy = Math.floor((mouse.y + camera.y) / TILE_SIZE);
                const key = `${wx},${wy}`;
                const targetBlock = world[key];
                if (targetBlock) {
                    if (miningTarget && miningTarget.key === key) {
                        miningProgress += getMiningSpeed();
                        const block = BLOCK_TYPES[targetBlock];
                        if (Math.random() < 0.3) createParticles((wx+0.5)*TILE_SIZE, (wy+0.5)*TILE_SIZE, block.color, 1);
                        if (miningProgress >= block.hardness) { 
                            let dropId = block.dropId || block.drop || targetBlock;
                            if (player.gameMode !== 'creative') addItemToInventory(dropId, 1); 
                            createParticles((wx+0.5)*TILE_SIZE, (wy+0.5)*TILE_SIZE, block.color, 8);
                            delete world[key]; updateHUD(); miningTarget = null; miningProgress = 0; 
                        }
                    } else { miningTarget = { wx, wy, key }; miningProgress = 0; }
                } else { miningTarget = null; miningProgress = 0; }
            } else { miningTarget = null; miningProgress = 0; }

            let curSpeed = keys['shift'] ? SPRINT_SPEED : SPEED;
            if (player.isFlying) curSpeed *= 1.5;

            if (keys['a'] || keys['arrowleft']) { player.vx -= curSpeed; player.facing = -1; player.animTimer += 0.2; }
            if (keys['d'] || keys['arrowright']) { player.vx += curSpeed; player.facing = 1; player.animTimer += 0.2; }
            player.vx *= FRICTION; 
            player.x += player.vx; resolveCollision('x');

            if (player.isFlying) {
                if (keys['w'] || keys[' ']) player.vy = -6;
                else if (keys['s'] || keys['shift']) player.vy = 6;
                else player.vy *= 0.8;
            } else {
                if ((keys['w'] || keys[' '] || keys['arrowup']) && player.grounded) { 
                    player.vy = JUMP; 
                    player.grounded = false; 
                    player.squash = 1.3; 
                }
                player.vy += GRAVITY;
            }

            player.y += player.vy; 
            player.squash += (1 - player.squash) * 0.15;
            
            player.grounded = false;
            if (player.y + player.h > WORLD_HEIGHT * TILE_SIZE) takeDamage(10); resolveCollision('y');
            camera.x += (player.x - width/2 - camera.x) * 0.1; camera.y += (player.y - height/2 - camera.y) * 0.1;
            document.getElementById('coords').innerText = `X: ${Math.floor(player.x/TILE_SIZE)} Y: ${Math.floor(player.y/TILE_SIZE)}`;
        }

        function resolveCollision(axis) {
            const world = worlds[currentDimension];
            const x1 = Math.floor(player.x / TILE_SIZE), x2 = Math.floor((player.x + player.w - 1) / TILE_SIZE);
            const y1 = Math.floor(player.y / TILE_SIZE), y2 = Math.floor((player.y + player.h - 1) / TILE_SIZE);
            for (let x = x1; x <= x2; x++) {
                for (let y = y1; y <= y2; y++) {
                    const type = world[`${x},${y}`];
                    if (type) {
                        const block = BLOCK_TYPES[type]; 
                        if (block.hazard) { takeDamage(1); if (block.id !== 6) continue; }
                        if (block.teleport) continue; 
                        
                        if (player.isFlying) continue; 

                        if (axis === 'x') { if (player.vx > 0) player.x = x * TILE_SIZE - player.w; else if (player.vx < 0) player.x = (x + 1) * TILE_SIZE; player.vx = 0; }
                        else { 
                            if (player.vy > 0) { 
                                if (!player.grounded) player.squash = 0.7;
                                player.y = y * TILE_SIZE - player.h; player.grounded = true; 
                            } else if (player.vy < 0) { player.y = (y + 1) * TILE_SIZE; } player.vy = 0; 
                        }
                    }
                }
            }
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }

        function drawBlock(x, y, type) {
            const b = BLOCK_TYPES[type];
            if(!b) return;
            const tx = x * TILE_SIZE;
            const ty = y * TILE_SIZE;
            const time = Date.now() / 300;

            ctx.fillStyle = b.color;
            if (b.animated) {
                if (type === 60) ctx.fillStyle = `hsl(${280 + Math.sin(time + x + y) * 30}, 70%, 30%)`;
                if (type === 6 || type === 62) ctx.fillStyle = `hsl(${15 + Math.sin(time + x * 0.5) * 5}, 90%, ${40 + Math.sin(time + y) * 10}%)`;
                if (type === 52) ctx.fillStyle = `hsl(50, 90%, ${70 + Math.sin(time) * 10}%)`;
            }
            ctx.fillRect(tx, ty, TILE_SIZE, TILE_SIZE);

            if (type === 1) { 
                ctx.fillStyle = b.topColor;
                ctx.fillRect(tx, ty, TILE_SIZE, 8);
                ctx.fillRect(tx, ty+8, 4, 4); ctx.fillRect(tx+12, ty+8, 8, 4); ctx.fillRect(tx+28, ty+8, 6, 4);
            } else if (b.texture === 'stone' || b.texture === 'cobble' || b.texture === 'netherrack') {
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(tx+4, ty+4, 8, 8); ctx.fillRect(tx+20, ty+18, 12, 12);
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fillRect(tx+25, ty+5, 6, 6); ctx.fillRect(tx+8, ty+25, 10, 10);
            }

            if (b.ore) {
                ctx.fillStyle = b.ore;
                ctx.fillRect(tx+6, ty+8, 6, 6); ctx.fillRect(tx+24, ty+14, 8, 8); ctx.fillRect(tx+10, ty+26, 6, 6);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(tx+6, ty+8, 2, 2); ctx.fillRect(tx+24, ty+14, 3, 3);
            }

            if (type === 11) { 
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(tx + TILE_SIZE/2, ty + TILE_SIZE/2, TILE_SIZE/2.5, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(tx + TILE_SIZE/2, ty + TILE_SIZE/2);
                const angle = time;
                ctx.lineTo(tx + TILE_SIZE/2 + Math.cos(angle)*10, ty + TILE_SIZE/2 + Math.sin(angle)*10);
                ctx.stroke();
            }

            ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 2;
            ctx.strokeRect(tx+1, ty+1, TILE_SIZE-2, TILE_SIZE-2);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.strokeRect(tx, ty, TILE_SIZE, TILE_SIZE);
            
            if (miningTarget && miningTarget.wx === x && miningTarget.wy === y) {
                const stage = Math.floor((miningProgress / b.hardness) * 5);
                if (stage > 0) {
                    ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 3;
                    for (let i = 0; i < stage; i++) {
                        ctx.beginPath(); ctx.moveTo(tx+(i*8), ty); ctx.lineTo(tx+TILE_SIZE, ty+TILE_SIZE-(i*8)); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(tx, ty+(i*8)); ctx.lineTo(tx+TILE_SIZE-(i*8), ty+TILE_SIZE); ctx.stroke();
                    }
                }
            }
        }

        function draw() {
            const bgColor = currentDimension === 'overworld' ? '#4a90e2' : '#1a0505';
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, width, height);
            
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            
            const world = worlds[currentDimension];
            if (world) {
                const v1 = Math.max(0, Math.floor(camera.x/TILE_SIZE)-1), v2 = Math.min(WORLD_WIDTH-1, Math.ceil((camera.x+width)/TILE_SIZE)+1);
                const v3 = Math.max(0, Math.floor(camera.y/TILE_SIZE)-1), v4 = Math.min(WORLD_HEIGHT-1, Math.ceil((camera.y+height)/TILE_SIZE)+1);

                for (let x = v1; x <= v2; x++) {
                    for (let y = v3; y <= v4; y++) {
                        const type = world[`${x},${y}`];
                        if (type) drawBlock(x, y, type);
                    }
                }
            }

            particles.forEach(p => {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 50;
                ctx.fillRect(p.x, p.y, 6, 6);
            });
            ctx.globalAlpha = 1;

            if (!player.dead && player.invuln % 6 < 3) {
                ctx.save(); 
                ctx.translate(player.x + player.w/2, player.y + player.h);
                ctx.scale(player.facing, player.squash);
                ctx.translate(-player.w/2, -player.h);

                ctx.fillStyle = '#ffb6c1';
                ctx.fillRect(0, 4, player.w, player.h - 10);
                ctx.strokeStyle = '#ff69b4'; ctx.lineWidth = 2;
                ctx.strokeRect(0, 4, player.w, player.h - 10);

                ctx.fillStyle = '#ffb6c1';
                ctx.fillRect(4, player.h - 8, 8, 8 + (player.grounded ? 0 : 2));
                ctx.fillRect(player.w - 12, player.h - 8, 8, 8 - (player.grounded ? 0 : 2));
                
                ctx.fillStyle = '#ff69b4';
                ctx.fillRect(player.w - 6, 12, 10, 10);
                ctx.fillStyle = '#c71585';
                ctx.fillRect(player.w + 1, 15, 2, 2); ctx.fillRect(player.w + 1, 19, 2, 2);

                ctx.fillStyle = '#000';
                ctx.fillRect(player.w - 10, 8, 4, 4);

                ctx.strokeStyle = '#ff69b4'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, 10); ctx.quadraticCurveTo(-10, 5, -5, 0); ctx.stroke();

                if (player.isFlying) {
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.fillRect(-10, 10, 10, 5);
                    ctx.fillRect(player.w, 10, 10, 5);
                }

                ctx.restore();
            }
            ctx.restore();
        }
        init();
    </script>
</body>
</html>
