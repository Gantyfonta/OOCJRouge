
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Moinkcraft: The Smelting Update</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press+Start+2P', cursive;
            background: #0d0d1a;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #4a90e2;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            image-rendering: pixelated;
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #title-screen {
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            text-align: center;
            padding: 20px;
            overflow-y: auto;
        }

        #mode-selection-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 210;
        }

        #pause-menu {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 150;
            text-align: center;
        }

        .floating-numbers {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }

        .time-particle {
            position: absolute;
            font-size: 20px;
            color: rgba(212, 175, 55, 0.2);
            animation: driftUp 10s linear infinite;
        }

        @keyframes driftUp {
            0% { transform: translateY(110vh) rotate(0deg); opacity: 0; }
            20% { opacity: 0.5; }
            80% { opacity: 0.5; }
            100% { transform: translateY(-10vh) rotate(360deg); opacity: 0; }
        }

        .hero-scene {
            position: relative;
            width: 160px;
            height: 180px;
            margin-bottom: 20px;
            z-index: 10;
        }

        .title-clock {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background: #f1c40f;
            border: 6px solid #b8860b;
            border-radius: 50%;
            box-shadow: 0 6px 0 #8b6b00, 0 10px 20px rgba(0,0,0,0.5);
        }

        .title-clock::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 3px; height: 25px;
            background: #333;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: translate(-50%, -100%) rotate(0deg); }
            to { transform: translate(-50%, -100%) rotate(360deg); }
        }

        .title-pig {
            position: absolute;
            width: 50px;
            height: 40px;
            background: #ffb6c1;
            bottom: 95px;
            left: 50%;
            margin-left: -25px;
            border-bottom: 4px solid #ff69b4;
            border-radius: 4px;
            animation: pigJump 1.2s cubic-bezier(0.45, 0, 0.55, 1) infinite;
        }

        .title-pig::before { content: ''; position: absolute; right: -6px; top: 18px; width: 10px; height: 14px; background: #ff69b4; border-right: 2px solid #c71585; border-radius: 2px; }
        .title-pig::after { content: ''; position: absolute; right: 10px; top: 10px; width: 6px; height: 6px; background: #000; box-shadow: -18px 0 0 #000; border-radius: 1px; }

        @keyframes pigJump {
            0%, 100% { transform: translateY(0) scaleY(1); }
            50% { transform: translateY(-80px) scaleY(1.1); }
            95% { transform: translateY(6px) scaleY(0.75); }
        }

        .game-title {
            font-size: 28px;
            color: #ffb6c1;
            text-shadow: 4px 4px 0px #c71585, 6px 6px 0px rgba(0,0,0,0.4);
            margin-bottom: 20px;
            letter-spacing: -2px;
            z-index: 10;
            position: relative;
        }

        .game-title span { color: #f1c40f; text-shadow: 4px 4px 0px #b8860b; }

        .worlds-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 400px;
            z-index: 10;
            padding: 10px;
        }

        .world-slot {
            background: #444;
            border: 4px solid;
            border-color: #666 #222 #222 #666;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .world-slot.empty { opacity: 0.7; }

        .world-info { text-align: left; flex: 1; }
        .world-name { font-size: 10px; color: #fff; margin-bottom: 6px; }
        .world-meta { font-size: 7px; color: #aaa; }

        .slot-actions { display: flex; gap: 8px; }

        .btn-mini { padding: 8px; font-size: 8px; background: #5b8a3e; border: 3px solid; border-color: #92c47c #2d451f #2d451f #92c47c; color: #fff; cursor: pointer; }
        .btn-mini.red { background: #b71c1c; border-color: #ef5350 #7f0000 #7f0000 #ef5350; }
        .btn-mini:hover { filter: brightness(1.2); }

        .hud-anchor {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: none;
            z-index: 50;
        }

        .hotbar-hud { display: flex; background: rgba(0, 0, 0, 0.6); padding: 4px; border: 4px solid #1a1a1a; pointer-events: auto; }
        .hud-slot { width: 52px; height: 52px; border: 4px solid transparent; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.05); position: relative; cursor: crosshair; }
        .hud-slot.active { border-color: #fff; background: rgba(255, 255, 255, 0.25); box-shadow: inset 0 0 10px rgba(255,255,255,0.5); }

        #inventory-screen { position: absolute; inset: 0; background: rgba(0, 0, 0, 0.7); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
        .mc-container { background: #c6c6c6; border: 6px solid; border-color: #eee #444 #444 #eee; padding: 20px; box-shadow: 8px 8px 0 rgba(0,0,0,0.6); display: flex; flex-direction: column; gap: 15px; position: relative; width: 600px; }
        .mc-label { color: #222; font-size: 9px; margin-bottom: 6px; font-weight: bold; }
        .mc-slot { width: 48px; height: 48px; background: #8b8b8b; border: 4px solid; border-color: #373737 #fefefe #fefefe #373737; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; }
        .mc-slot:hover { background: #aaa; box-shadow: inset 0 0 0 2px rgba(255,255,255,0.3); }
        .mc-slot.output { width: 56px; height: 56px; border-width: 5px; }
        .mc-grid { display: grid; gap: 4px; }
        #main-inventory-grid { max-height: 220px; overflow-y: auto; padding: 2px; }
        .top-section { display: flex; gap: 40px; align-items: flex-start; }
        .crafting-section { display: flex; align-items: center; gap: 20px; }
        .crafting-grid-2x2 { display: grid; grid-template-columns: repeat(2, 48px); gap: 4px; }
        .crafting-grid-3x3 { display: grid; grid-template-columns: repeat(3, 48px); gap: 4px; }
        .arrow-right { width: 34px; height: 24px; background: #444; clip-path: polygon(0% 20%, 60% 20%, 60% 0%, 100% 50%, 60% 100%, 60% 80%, 0% 80%); }
        .block-icon { width: 34px; height: 34px; pointer-events: none; position: relative; display: flex; align-items: center; justify-content: center; }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 11px; color: #fff; text-shadow: 2px 2px #000; font-weight: bold; pointer-events: none; z-index: 10; }
        #held-item-cursor { position: fixed; pointer-events: none; z-index: 1000; display: none; filter: drop-shadow(4px 4px 2px rgba(0,0,0,0.5)); }
        
        #item-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(16, 0, 16, 0.9);
            border: 2px solid #2d0a63;
            color: #fff;
            padding: 8px 12px;
            font-size: 8px;
            z-index: 2000;
            display: none;
            white-space: pre-wrap;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
            line-height: 1.4;
        }

        .status-ui { position: absolute; top: 25px; left: 25px; display: flex; flex-direction: column; gap: 12px; }
        .hearts { display: flex; gap: 6px; pointer-events: none; }
        .heart { width: 22px; height: 22px; background: #ff4d4d; border: 3px solid #7a0000; box-shadow: 3px 3px 0 rgba(0,0,0,0.3); border-radius: 4px; }
        .heart.empty { background: #222; border-color: #000; box-shadow: none; }
        #death-screen { position: absolute; inset: 0; background: rgba(30,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 101; }
        .btn { margin-top: 15px; padding: 15px 30px; background: #5b8a3e; border: 6px solid; border-color: #92c47c #2d451f #2d451f #92c47c; color: #fff; cursor: pointer; font-size: 12px; pointer-events: auto; text-align: center; box-shadow: 6px 6px 0 rgba(0,0,0,0.4); z-index: 10; transition: transform 0.1s; }
        .btn:hover { background: #6da34a; transform: scale(1.05); }
        .btn.grey { background: #888; border-color: #bbb #444 #444 #bbb; }
        .btn.gold { background: #f1c40f; border-color: #f9e79f #b8860b #b8860b #f9e79f; color: #333; }
        #portal-overlay {
            position: absolute;
            inset: 0;
            background: #4a148c;
            opacity: 0;
            z-index: 300;
            pointer-events: none;
            transition: opacity 1s;
        }
        #save-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            font-size: 8px;
            color: #76b052;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        /* Furnace Specific Styles */
        .furnace-section { display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 20px; border: 4px solid #373737; background: #8b8b8b; }
        .furnace-main { display: flex; align-items: center; gap: 20px; }
        .furnace-fuel-area { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .furnace-flame { width: 28px; height: 28px; background: #444; clip-path: polygon(50% 0%, 80% 30%, 100% 70%, 100% 100%, 0% 100%, 0% 70%, 20% 30%); position: relative; }
        .furnace-flame.active { background: #ff5722; box-shadow: 0 0 10px #ff5722; animation: flicker 0.2s infinite; }
        .furnace-flame-inner { position: absolute; bottom: 0; width: 100%; background: #ffeb3b; }
        .cook-progress-arrow { width: 40px; height: 28px; background: #444; clip-path: polygon(0% 20%, 60% 20%, 60% 0%, 100% 50%, 60% 100%, 60% 80%, 0% 80%); position: relative; }
        .cook-progress-fill { position: absolute; left: 0; top: 0; height: 100%; background: #76b052; width: 0%; transition: width 0.1s linear; }

        @keyframes flicker {
            0% { opacity: 0.9; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0.9; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="portal-overlay"></div>
        <div id="held-item-cursor"></div>
        <div id="item-tooltip"></div>
        <div id="save-indicator">SAVING...</div>
        
        <div id="mode-selection-overlay">
            <h2 style="font-size: 20px; color: #fff; margin-bottom: 30px; text-shadow: 4px 4px #000;">SELECT GAME MODE</h2>
            <div style="display: flex; gap: 20px;">
                <div style="flex: 1; text-align: center;">
                    <div class="btn" style="width: 200px;" onclick="confirmNewWorld('survival')">SURVIVAL</div>
                    <div style="font-size: 7px; color: #aaa; margin-top: 10px; line-height: 1.5;">Limited life.<br>Mine for resources.<br>Hunger and danger!</div>
                </div>
                <div style="flex: 1; text-align: center;">
                    <div class="btn gold" style="width: 200px;" onclick="confirmNewWorld('creative')">CREATIVE</div>
                    <div style="font-size: 7px; color: #f1c40f; margin-top: 10px; line-height: 1.5;">Invincibility.<br>Double jump to fly.<br>Infinite blocks!</div>
                </div>
            </div>
            <div class="btn grey" style="margin-top: 40px; padding: 10px 20px;" onclick="closeModeSelection()">CANCEL</div>
        </div>

        <div id="pause-menu">
            <h2 style="font-size: 24px; color: #fff; margin-bottom: 30px; text-shadow: 4px 4px #000;">GAME PAUSED</h2>
            <div class="btn" onclick="togglePauseMenu()">RESUME</div>
            <div class="btn grey" onclick="saveAndQuit()">SAVE AND QUIT</div>
        </div>

        <div id="title-screen">
            <div class="floating-numbers" id="floating-numbers"></div>
            <div class="hero-scene">
                <div class="title-pig"></div>
                <div class="title-clock"></div>
            </div>
            <h1 class="game-title">MOINK <span>O'CLOCK</span></h1>
            
            <div class="mc-label" style="color: #aaa; font-size: 10px; margin-bottom: 5px;">SELECT WORLD</div>
            <div class="worlds-container" id="worlds-container">
                <div class="world-slot empty" id="slot-0">
                    <div class="world-info">
                        <div class="world-name">SLOT 1</div>
                        <div class="world-meta">EMPTY WORLD</div>
                    </div>
                    <div class="slot-actions">
                        <button class="btn-mini" onclick="handleSlotAction(0, 'play')">NEW</button>
                    </div>
                </div>
                <div class="world-slot empty" id="slot-1">
                    <div class="world-info">
                        <div class="world-name">SLOT 2</div>
                        <div class="world-meta">EMPTY WORLD</div>
                    </div>
                    <div class="slot-actions">
                        <button class="btn-mini" onclick="handleSlotAction(1, 'play')">NEW</button>
                    </div>
                </div>
                <div class="world-slot empty" id="slot-2">
                    <div class="world-info">
                        <div class="world-name">SLOT 3</div>
                        <div class="world-meta">EMPTY WORLD</div>
                    </div>
                    <div class="slot-actions">
                        <button class="btn-mini" onclick="handleSlotAction(2, 'play')">NEW</button>
                    </div>
                </div>
            </div>

            <div style="font-size: 6px; color: #555; margin-top: 20px;">ESC: PAUSE | WASD: MOVE | SPACE: JUMP | E: INV</div>
        </div>
        <div class="ui-overlay">
            <div class="status-ui">
                <div id="coords" style="font-size: 10px; color: #fff; text-shadow: 2px 2px #000;">X: 0 Y: 0</div>
                <div id="dim-indicator" style="font-size: 10px; color: #ffb6c1; text-shadow: 2px 2px #000;">Overworld</div>
                <div id="mode-indicator" style="font-size: 7px; color: #aaa;">Survival Mode</div>
            </div>
            <div class="hud-anchor">
                <div class="hearts" id="hearts-container"></div>
                <div class="hotbar-hud" id="hotbar-hud"></div>
            </div>
        </div>
        <div id="inventory-screen">
            <div class="mc-container" id="mc-inventory">
                <div class="top-section">
                    <div id="pig-preview" style="width: 100px; height: 120px; background: #8b8b8b; border: 4px solid #373737; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;">
                        <span style="font-size: 8px; color: #444; font-weight: bold;">PIGGY</span>
                        <div style="position: absolute; width: 40px; height: 30px; background: #ffb6c1; border: 2px solid #ff69b4; border-radius: 2px;">
                           <div style="position: absolute; right: 2px; top: 4px; width: 4px; height: 4px; background: #000;"></div>
                        </div>
                    </div>
                    
                    <div id="crafting-view">
                        <div class="mc-label" id="crafting-label">Crafting</div>
                        <div class="crafting-section">
                            <div class="crafting-grid-2x2" id="crafting-grid-2x2">
                                <div class="mc-slot" data-type="craft2" data-idx="0"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="1"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="2"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="3"></div>
                            </div>
                            <div class="crafting-grid-3x3" id="crafting-grid-3x3" style="display: none;">
                                <div class="mc-slot" data-type="craft3" data-idx="0"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="1"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="2"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="3"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="4"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="5"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="6"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="7"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="8"></div>
                            </div>
                            <div class="arrow-right"></div>
                            <div class="mc-slot output" id="crafting-output"></div>
                        </div>
                    </div>

                    <div id="furnace-view" style="display: none;">
                        <div class="mc-label">Furnace</div>
                        <div class="furnace-section">
                            <div class="furnace-main">
                                <div class="furnace-fuel-area">
                                    <div class="mc-slot" data-type="furnace-input" data-idx="0"></div>
                                    <div class="furnace-flame" id="furnace-flame"><div class="furnace-flame-inner" id="furnace-flame-inner"></div></div>
                                    <div class="mc-slot" data-type="furnace-fuel" data-idx="0"></div>
                                </div>
                                <div class="cook-progress-arrow">
                                    <div class="cook-progress-fill" id="cook-progress-fill"></div>
                                </div>
                                <div class="mc-slot output" data-type="furnace-output" data-idx="0"></div>
                            </div>
                        </div>
                    </div>

                </div>
                <div>
                    <div class="mc-label" id="inventory-label">Inventory</div>
                    <div class="mc-grid" style="grid-template-columns: repeat(9, 48px);" id="main-inventory-grid"></div>
                </div>
                <div style="margin-top: 8px;">
                    <div class="mc-grid" style="grid-template-columns: repeat(9, 48px);" id="hotbar-inventory-grid"></div>
                </div>
            </div>
        </div>
        <div id="death-screen">
            <h1 style="color: #ff4d4d; font-size: 24px; margin-bottom: 25px; text-shadow: 4px 4px #000;">YOU FAILED THE OINK</h1>
            <div class="btn" onclick="respawn()">START NEW CYCLE</div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 40;
        const TICKS_PER_SECOND = 20;
        const TICK_TIME = 1000 / TICKS_PER_SECOND;
        
        const GRAVITY = 1.8; 
        const FRICTION = 0.65; 
        const SPEED = 8.0; 
        const SPRINT_SPEED = 14.0; 
        const JUMP = -16; 
        const MAX_HEALTH = 10;
        const INVULN_TIME = 15; 
        const WORLD_WIDTH = 100;
        const WORLD_HEIGHT = 100;

        const BLOCK_TYPES = {
            1: { name: 'Grass', color: '#5b8a3e', stroke: '#3e5b2e', hardness: 10, tool: 'shovel', topColor: '#76b052' },
            2: { name: 'Dirt', color: '#7a5a3a', stroke: '#4d3a24', hardness: 12, tool: 'shovel' },
            3: { name: 'Stone', color: '#828282', stroke: '#555555', hardness: 50, tool: 'pickaxe', texture: 'stone', requiredTier: 1, drop: 7 },
            4: { name: 'Wood', color: '#6d4c41', stroke: '#3e2723', hardness: 30, tool: 'axe' },
            5: { name: 'Leaves', color: '#2e7d32', stroke: '#1b5e20', hardness: 5 },
            6: { name: 'Lava', color: '#ff5722', stroke: '#bf360c', hazard: true, hardness: 9999, animated: true, fluid: true, type: 'lava' },
            7: { name: 'Cobble', color: '#616161', stroke: '#424242', hardness: 45, tool: 'pickaxe', texture: 'cobble', requiredTier: 1 },
            8: { name: 'Sand', color: '#ffecb3', stroke: '#ffe082', hardness: 10, tool: 'shovel' },
            9: { name: 'Glass', color: 'rgba(200, 240, 255, 0.4)', stroke: '#fff', hardness: 5, texture: 'glass' },
            10: { name: 'Planks', color: '#d2b48c', stroke: '#8b4513', hardness: 25, tool: 'axe' },
            11: { name: 'Clock', color: '#fdd835', stroke: '#f9a825', special: true, hardness: 80, tool: 'pickaxe', requiredTier: 2 },
            12: { name: 'Crafting Table', color: '#795548', stroke: '#3e2723', hardness: 40, table: true, tool: 'axe' },
            13: { name: 'Coal Ore', color: '#828282', stroke: '#555555', hardness: 55, ore: '#212121', tool: 'pickaxe', drop: 30, requiredTier: 1 },
            14: { name: 'Iron Ore', color: '#828282', stroke: '#555555', hardness: 75, ore: '#d7ccc8', tool: 'pickaxe', drop: 14, requiredTier: 1 }, 
            15: { name: 'Stick', color: '#5d4037', stroke: '#3e2723', hardness: 10, item: true },
            16: { name: 'Wood Pickaxe', color: '#6d4c41', toolType: 'pickaxe', tier: 1, item: true },
            17: { name: 'Wood Shovel', color: '#6d4c41', toolType: 'shovel', tier: 1, item: true },
            18: { name: 'Wood Axe', color: '#6d4c41', toolType: 'axe', tier: 1, item: true },
            19: { name: 'Stone Pickaxe', color: '#616161', toolType: 'pickaxe', tier: 2, item: true },
            20: { name: 'Stone Shovel', color: '#616161', toolType: 'shovel', tier: 2, item: true },
            21: { name: 'Stone Axe', color: '#616161', toolType: 'axe', tier: 2, item: true },
            22: { name: 'Iron Pickaxe', color: '#e0e0e0', toolType: 'pickaxe', tier: 3, item: true },
            23: { name: 'Iron Shovel', color: '#e0e0e0', toolType: 'shovel', tier: 3, item: true },
            24: { name: 'Iron Axe', color: '#e0e0e0', toolType: 'axe', tier: 3, item: true },
            25: { name: 'Gold Ore', color: '#828282', stroke: '#555555', hardness: 80, ore: '#ffeb3b', tool: 'pickaxe', drop: 25, requiredTier: 1 },
            26: { name: 'Diamond Ore', color: '#828282', stroke: '#555555', hardness: 150, ore: '#00e5ff', tool: 'pickaxe', drop: 33, requiredTier: 3 },
            27: { name: 'Redstone Ore', color: '#828282', stroke: '#555555', hardness: 70, ore: '#ff1744', tool: 'pickaxe', drop: 34, requiredTier: 3 },
            28: { name: 'Obsidian', color: '#212121', stroke: '#1a1a1a', hardness: 600, tool: 'pickaxe', texture: 'obsidian', requiredTier: 4 },
            29: { name: 'Bedrock', color: '#1a1a1a', stroke: '#000000', hardness: 999999 },
            30: { name: 'Coal', color: '#212121', item: true, type: 'coal' },
            31: { name: 'Iron Ingot', color: '#f5f5f5', stroke: '#bdbdbd', item: true, type: 'ingot' },
            32: { name: 'Gold Ingot', color: '#fff176', stroke: '#fbc02d', item: true, type: 'ingot' },
            33: { name: 'Diamond', color: '#00e5ff', stroke: '#00b8d4', item: true, type: 'gem' },
            34: { name: 'Redstone Dust', color: '#ff1744', item: true, type: 'dust' },
            35: { name: 'Ladder', color: '#8d6e63', stroke: '#5d4037', hardness: 15, tool: 'axe', ladder: true },
            67: { name: 'Furnace', color: '#757575', stroke: '#424242', hardness: 50, tool: 'pickaxe', furnace: true },
            82: { name: 'Diamond Pickaxe', color: '#00e5ff', toolType: 'pickaxe', tier: 4, item: true },
            83: { name: 'Diamond Shovel', color: '#00e5ff', toolType: 'shovel', tier: 4, item: true },
            84: { name: 'Diamond Axe', color: '#00e5ff', toolType: 'axe', tier: 4, item: true },
            51: { name: 'Netherrack', color: '#b71c1c', stroke: '#7f0000', hardness: 15, tool: 'pickaxe', texture: 'netherrack', requiredTier: 1 },
            52: { name: 'Glowstone', color: '#fff59d', stroke: '#fbc02d', hardness: 10, animated: true },
            57: { name: 'Gravel', color: '#bdbdbd', stroke: '#9e9e9e', hardness: 10, tool: 'shovel', dropChance: 0.1, dropId: 58 },
            58: { name: 'Flint', color: '#424242', item: true },
            59: { name: 'Flint and Steel', color: '#e0e0e0', item: true, action: 'ignite' },
            60: { name: 'Nether Portal', color: '#6a1b9a', stroke: '#4a148c', hardness: 999, animated: true, teleport: true },
            63: { name: 'Water', color: '#0f5e9c', stroke: '#083d66', hardness: 9999, animated: true, fluid: true, type: 'water' },
            64: { name: 'Bucket', color: '#9e9e9e', stroke: '#616161', item: true, type: 'bucket' },
            65: { name: 'Water Bucket', color: '#9e9e9e', stroke: '#0f5e9c', item: true, type: 'bucket_water' },
            66: { name: 'Lava Bucket', color: '#9e9e9e', stroke: '#ff5722', item: true, type: 'bucket_lava' }
        };

        const RECIPES = [
            { pattern: [[4]], result: 10, amount: 4 },
            { pattern: [[10], [10]], result: 15, amount: 4 },
            { pattern: [[10, 10], [10, 10]], result: 12, amount: 1 },
            { pattern: [[15, null, 15], [15, 15, 15], [15, null, 15]], result: 35, amount: 3 },
            { pattern: [[7, 7, 7], [7, null, 7], [7, 7, 7]], result: 67, amount: 1 }, 
            { pattern: [[7, 7, 7], [null, 15, null], [null, 15, null]], result: 19, amount: 1 },
            { pattern: [[10, 10, 10], [null, 15, null], [null, 15, null]], result: 16, amount: 1 },
            { pattern: [[31, 31, 31], [null, 15, null], [null, 15, null]], result: 22, amount: 1 },
            { pattern: [[33, 33, 33], [null, 15, null], [null, 15, null]], result: 82, amount: 1 },
            { pattern: [[10], [15], [15]], result: 17, amount: 1 },
            { pattern: [[7], [15], [15]], result: 20, amount: 1 },
            { pattern: [[31], [15], [15]], result: 23, amount: 1 },
            { pattern: [[33], [15], [15]], result: 83, amount: 1 },
            { pattern: [[10, 10], [10, 15], [null, 15]], result: 18, amount: 1 },
            { pattern: [[7, 7], [7, 15], [null, 15]], result: 21, amount: 1 },
            { pattern: [[31, 31], [31, 15], [null, 15]], result: 24, amount: 1 },
            { pattern: [[33, 33], [33, 15], [null, 15]], result: 84, amount: 1 },
            { pattern: [[null, 32, null], [32, 15, 32], [null, 32, null]], result: 11, amount: 1 },
            { pattern: [[31, null, 31], [null, 31, null]], result: 64, amount: 1 },
            { pattern: [[58, 31]], result: 59, amount: 1 }
        ];

        const SMELTING_RECIPES = {
            7: { result: 3, time: 200 }, 
            14: { result: 31, time: 200 }, 
            25: { result: 32, time: 200 }, 
            8: { result: 9, time: 200 } 
        };

        const FUEL_VALUES = {
            30: 1600, 
            4: 300,   
            10: 300,  
            15: 100   
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const heartsContainer = document.getElementById('hearts-container');
        const portalOverlay = document.getElementById('portal-overlay');
        const saveIndicator = document.getElementById('save-indicator');
        const pauseMenuEl = document.getElementById('pause-menu');
        const modeSelectionEl = document.getElementById('mode-selection-overlay');
        const itemTooltipEl = document.getElementById('item-tooltip');
        
        let width, height;
        let camera = { x: 0, y: 0 };
        let currentDimension = 'overworld';
        let worlds = { overworld: {}, nether: {} };
        let tileEntities = { overworld: {}, nether: {} };
        let teleportTimer = 0;
        let activeSaveSlot = null;
        let pendingSaveSlot = null;
        
        let player = { 
            x: (WORLD_WIDTH / 2) * TILE_SIZE, 
            y: 0, 
            vx: 0, 
            vy: 0, 
            w: 34, 
            h: 28, 
            grounded: false, 
            health: MAX_HEALTH, 
            invuln: 0, 
            dead: false, 
            facing: 1,
            animTimer: 0,
            squash: 1,
            gameMode: 'survival', 
            isFlying: false,
            lastJumpTime: 0
        };
        
        let mainInventory = new Array(27).fill(null);
        let hotbarInventory = new Array(9).fill(null);
        let craftingGrid2x2 = new Array(4).fill(null);
        let craftingGrid3x3 = new Array(9).fill(null);
        let craftingOutput = null;
        let activeRecipeMatch = null;
        let heldItem = null;

        let isUsingTable = false;
        let activeFurnacePos = null; 

        let miningTarget = null;
        let miningProgress = 0;
        let activeHotbarIndex = 0; 
        let inventoryOpen = false;
        let isPaused = false;
        let gameStarted = false;
        let keys = {};
        let mouse = { x: 0, y: 0, down: false, rightDown: false };
        let particles = [];

        let lastTimestamp = 0;
        let tickAccumulator = 0;

        function init() {
            resize();
            updateSlotsUI();
            setupInventoryUI();
            setupTitleParticles();

            window.addEventListener('resize', resize);
            window.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                if (!gameStarted) { keys[key] = true; return; }
                if (e.key === 'Escape') { if (inventoryOpen) toggleInventory(); else togglePauseMenu(); }
                if (!isPaused) {
                    if (key === 'e') toggleInventory();
                    if (!inventoryOpen && e.key >= '1' && e.key <= '9') { activeHotbarIndex = parseInt(e.key) - 1; updateHUD(); }
                    if (!inventoryOpen && (key === 'w' || key === ' ')) {
                        const now = Date.now();
                        if (player.gameMode === 'creative' && now - player.lastJumpTime < 300) { player.isFlying = !player.isFlying; player.vy = 0; }
                        player.lastJumpTime = now;
                    }
                }
                keys[key] = true;
            });
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            window.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top;
                if (gameStarted) { updateHeldItemCursor(); updateTooltip(); }
            });
            window.addEventListener('mousedown', e => {
                if (!gameStarted || isPaused) return;
                if (e.button === 0) mouse.down = true;
                if (e.button === 2) { mouse.rightDown = true; if (!inventoryOpen) handleWorldInteraction(); }
            });
            window.addEventListener('mouseup', e => { if (e.button === 0) mouse.down = false; if (e.button === 2) mouse.rightDown = false; });
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            requestAnimationFrame(loop);
        }

        function togglePauseMenu() {
            if (player.dead) return;
            isPaused = !isPaused;
            pauseMenuEl.style.display = isPaused ? 'flex' : 'none';
        }

        function saveAndQuit() {
            saveGame();
            isPaused = false; gameStarted = false;
            pauseMenuEl.style.display = 'none';
            document.getElementById('title-screen').style.display = 'flex';
            updateSlotsUI();
        }

        function updateSlotsUI() {
            for (let i = 0; i < 3; i++) {
                const slotEl = document.getElementById(`slot-${i}`);
                const data = localStorage.getItem(`moinkcraft_world_${i}`);
                if (data) {
                    const parsed = JSON.parse(data);
                    slotEl.className = 'world-slot';
                    slotEl.querySelector('.world-meta').innerText = `SAVED: ${parsed.timestamp || 'N/A'}`;
                    slotEl.querySelector('.slot-actions').innerHTML = `
                        <button class="btn-mini" onclick="handleSlotAction(${i}, 'play')">PLAY</button>
                        <button class="btn-mini red" onclick="handleSlotAction(${i}, 'delete')">X</button>
                    `;
                } else {
                    slotEl.className = 'world-slot empty';
                    slotEl.querySelector('.world-meta').innerText = 'EMPTY WORLD';
                    slotEl.querySelector('.slot-actions').innerHTML = `
                        <button class="btn-mini" onclick="handleSlotAction(${i}, 'play')">NEW</button>
                    `;
                }
            }
        }

        function handleSlotAction(slot, action) {
            if (action === 'play') {
                const data = localStorage.getItem(`moinkcraft_world_${slot}`);
                if (data) {
                    activeSaveSlot = slot; loadGame(JSON.parse(data)); startGame();
                } else {
                    pendingSaveSlot = slot; modeSelectionEl.style.display = 'flex';
                }
            } else if (action === 'delete') {
                if (confirm('DELETE WORLD FOREVER?')) { localStorage.removeItem(`moinkcraft_world_${slot}`); updateSlotsUI(); }
            }
        }

        function closeModeSelection() { modeSelectionEl.style.display = 'none'; pendingSaveSlot = null; }

        function confirmNewWorld(mode) {
            activeSaveSlot = pendingSaveSlot; pendingSaveSlot = null;
            modeSelectionEl.style.display = 'none'; startNewWorld(mode); startGame();
        }

        function saveGame() {
            if (activeSaveSlot === null || player.dead) return;
            const saveData = {
                worlds,
                tileEntities,
                player: { x: player.x, y: player.y, health: player.health, dimension: currentDimension, gameMode: player.gameMode },
                inventory: { main: mainInventory, hotbar: hotbarInventory },
                timestamp: new Date().toLocaleString()
            };
            localStorage.setItem(`moinkcraft_world_${activeSaveSlot}`, JSON.stringify(saveData));
            showSaveIndicator();
        }

        function loadGame(data) {
            worlds = data.worlds; 
            tileEntities = data.tileEntities || { overworld: {}, nether: {} };
            player.x = data.player.x; player.y = data.player.y;
            player.health = data.player.health; player.gameMode = data.player.gameMode || 'survival';
            currentDimension = data.player.dimension || 'overworld';
            mainInventory = data.inventory.main; hotbarInventory = data.inventory.hotbar;
            player.isFlying = false; updateHUD(); updateHeartsUI(); 
        }

        function startNewWorld(mode = 'survival') {
            worlds = { overworld: {}, nether: {} };
            tileEntities = { overworld: {}, nether: {} };
            generateOverworld(); generateNether();
            mainInventory = new Array(27).fill(null); hotbarInventory = new Array(9).fill(null);
            
            const startX = Math.floor(WORLD_WIDTH / 2);
            let startY = 0;
            const world = worlds.overworld;
            while(!world[`${startX},${startY}`] && startY < WORLD_HEIGHT) startY++;
            player.x = startX * TILE_SIZE; player.y = (startY - 2) * TILE_SIZE;
            player.health = MAX_HEALTH; player.gameMode = mode;
            currentDimension = 'overworld'; updateHUD(); updateHeartsUI(); saveGame(); 
        }

        function showSaveIndicator() {
            saveIndicator.style.opacity = '1';
            setTimeout(() => { saveIndicator.style.opacity = '0'; }, 2000);
        }

        function createParticles(x, y, color, count = 5) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x, y, vx: (Math.random() - 0.5) * 5, vy: -Math.random() * 5, color, life: 30 + Math.random() * 20
                });
            }
        }

        function setupTitleParticles() {
            const container = document.getElementById('floating-numbers');
            for(let i=0; i<15; i++) {
                const p = document.createElement('div');
                p.className = 'time-particle'; p.innerText = Math.floor(Math.random() * 12) + 1;
                p.style.left = Math.random() * 100 + 'vw'; p.style.animationDelay = (Math.random() * 10) + 's';
                p.style.fontSize = (Math.random() * 20 + 20) + 'px'; container.appendChild(p);
            }
        }

        function startGame() { gameStarted = true; isPaused = false; document.getElementById('title-screen').style.display = 'none'; }
        function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }

        function toggleInventory(useTable = false, furnacePos = null) {
            if (isPaused) return;
            inventoryOpen = !inventoryOpen; 
            isUsingTable = useTable;
            activeFurnacePos = furnacePos;

            const screen = document.getElementById('inventory-screen');
            screen.style.display = inventoryOpen ? 'flex' : 'none';
            
            const craftView = document.getElementById('crafting-view');
            const furnaceView = document.getElementById('furnace-view');

            if (activeFurnacePos) {
                craftView.style.display = 'none';
                furnaceView.style.display = 'block';
            } else {
                craftView.style.display = 'block';
                furnaceView.style.display = 'none';
                document.getElementById('crafting-grid-2x2').style.display = (isUsingTable || player.gameMode === 'creative') ? 'none' : 'grid';
                document.getElementById('crafting-grid-3x3').style.display = isUsingTable ? 'grid' : 'none';
                document.getElementById('pig-preview').style.display = (isUsingTable || player.gameMode === 'creative') ? 'none' : 'flex';
            }

            if (!inventoryOpen) {
                const returnItems = (grid) => { grid.forEach((item, i) => { if (item) addItemToInventory(item.id, item.count); grid[i] = null; }); };
                if (!activeFurnacePos) {
                    returnItems(craftingGrid2x2); returnItems(craftingGrid3x3);
                }
                activeFurnacePos = null;
                if (heldItem && player.gameMode !== 'creative') { addItemToInventory(heldItem.id, heldItem.count); heldItem = null; }
                else if (heldItem) { heldItem = null; }
                updateHeldItemCursor(); saveGame();
            }
            itemTooltipEl.style.display = 'none'; renderInventory();
        }

        function setupInventoryUI() {
            const setupSlot = (slot) => {
                slot.addEventListener('mousedown', (e) => {
                    const type = slot.dataset.type; const idx = parseInt(slot.dataset.idx);
                    handleSlotClick(type, idx, e.button); e.preventDefault();
                });
                slot.addEventListener('contextmenu', (e) => e.preventDefault());
            };
            const mainGrid = document.getElementById('main-inventory-grid');
            mainGrid.innerHTML = '';
            for (let i = 0; i < 27; i++) {
                const slot = document.createElement('div'); slot.className = 'mc-slot';
                slot.dataset.type = 'main'; slot.dataset.idx = i; setupSlot(slot); mainGrid.appendChild(slot);
            }
            const hbGrid = document.getElementById('hotbar-inventory-grid');
            hbGrid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div'); slot.className = 'mc-slot';
                slot.dataset.type = 'hotbar'; slot.dataset.idx = i; setupSlot(slot); hbGrid.appendChild(slot);
            }
            document.querySelectorAll('#crafting-grid-2x2 .mc-slot').forEach(setupSlot);
            document.querySelectorAll('#crafting-grid-3x3 .mc-slot').forEach(setupSlot);
            document.querySelectorAll('#furnace-view .mc-slot').forEach(setupSlot);
            document.getElementById('crafting-output').addEventListener('mousedown', (e) => { if (e.button === 0) handleCraftingOutputClick(); });
        }

        function renderInventory() {
            const mainGrid = document.getElementById('main-inventory-grid');
            if (player.gameMode === 'creative' && !activeFurnacePos) {
                mainGrid.innerHTML = '';
                Object.keys(BLOCK_TYPES).forEach((id) => {
                    const slot = document.createElement('div');
                    slot.className = 'mc-slot'; slot.dataset.type = 'creative'; slot.dataset.itemId = id;
                    slot.appendChild(createItemVisual(parseInt(id), 1));
                    slot.addEventListener('mousedown', (e) => { handleSlotClick('creative', parseInt(id), e.button); e.preventDefault(); });
                    mainGrid.appendChild(slot);
                });
            } else {
                const slots = mainGrid.querySelectorAll('.mc-slot');
                mainInventory.forEach((item, i) => { 
                    const slot = slots[i]; if (!slot) return; slot.innerHTML = ''; 
                    if (item) slot.appendChild(createItemVisual(item.id, item.count)); 
                });
            }

            const hbSlots = document.getElementById('hotbar-inventory-grid').querySelectorAll('.mc-slot');
            hotbarInventory.forEach((item, i) => { 
                const slot = hbSlots[i]; if (!slot) return; slot.innerHTML = ''; 
                if (item) slot.appendChild(createItemVisual(item.id, item.count)); 
            });

            if (activeFurnacePos) {
                const f = tileEntities[currentDimension][activeFurnacePos];
                if (f) {
                    const slots = {
                        'furnace-input': f.input,
                        'furnace-fuel': f.fuel,
                        'furnace-output': f.output
                    };
                    document.querySelectorAll('#furnace-view .mc-slot').forEach(slot => {
                        const type = slot.dataset.type;
                        slot.innerHTML = '';
                        if (slots[type]) slot.appendChild(createItemVisual(slots[type].id, slots[type].count));
                    });
                    
                    const burnPercent = f.maxBurnTime > 0 ? (f.burnTime / f.maxBurnTime) * 100 : 0;
                    document.getElementById('furnace-flame-inner').style.height = burnPercent + '%';
                    document.getElementById('furnace-flame').className = f.burnTime > 0 ? 'furnace-flame active' : 'furnace-flame';
                    
                    const cookTarget = SMELTING_RECIPES[f.input?.id]?.time || 200;
                    const cookPercent = (f.cookProgress / cookTarget) * 100;
                    document.getElementById('cook-progress-fill').style.width = cookPercent + '%';
                }
            } else {
                const craftSlots2 = document.querySelectorAll('#crafting-grid-2x2 .mc-slot');
                craftingGrid2x2.forEach((item, i) => { if(craftSlots2[i]) { craftSlots2[i].innerHTML = ''; if (item) craftSlots2[i].appendChild(createItemVisual(item.id, item.count)); } });
                const craftSlots3 = document.querySelectorAll('#crafting-grid-3x3 .mc-slot');
                craftingGrid3x3.forEach((item, i) => { if(craftSlots3[i]) { craftSlots3[i].innerHTML = ''; if (item) craftSlots3[i].appendChild(createItemVisual(item.id, item.count)); } });
                checkRecipes();
                const outputSlot = document.getElementById('crafting-output');
                outputSlot.innerHTML = '';
                if (craftingOutput) outputSlot.appendChild(createItemVisual(craftingOutput.id, craftingOutput.count));
            }
            updateHUD();
        }

        function createItemVisual(id, count, scale = 1) {
            const block = BLOCK_TYPES[id];
            if (!block) return document.createElement('div');
            const container = document.createElement('div'); container.className = 'block-icon';
            const drawShape = (style) => {
                const div = document.createElement('div'); 
                Object.assign(div.style, style, { position: 'absolute' }); 
                container.appendChild(div);
            };

            const sizeMod = scale;
            if (block.type === 'ingot') {
                drawShape({ width: (24*sizeMod)+'px', height: (12*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, transform: 'rotate(-25deg)', borderRadius: '2px' });
            } else if (block.type === 'coal') {
                drawShape({ width: (18*sizeMod)+'px', height: (18*sizeMod)+'px', background: block.color, clipPath: 'polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)' });
            } else if (block.type === 'gem') {
                drawShape({ width: (18*sizeMod)+'px', height: (18*sizeMod)+'px', background: block.color, clipPath: 'polygon(50% 0%, 100% 40%, 80% 100%, 20% 100%, 0% 40%)' });
            } else if (block.texture === 'glass') {
                drawShape({ width: (30*sizeMod)+'px', height: (30*sizeMod)+'px', background: block.color, border: `2px solid #fff`, borderRadius: '2px' });
                drawShape({ width: (10*sizeMod)+'px', height: (2*sizeMod)+'px', background: '#fff', top: '5px', left: '5px' });
            } else if (id === 35) {
                // Ladder visual
                drawShape({ width: (4*sizeMod)+'px', height: (34*sizeMod)+'px', background: block.color, border: `${sizeMod}px solid ${block.stroke}`, left: (4*sizeMod)+'px' });
                drawShape({ width: (4*sizeMod)+'px', height: (34*sizeMod)+'px', background: block.color, border: `${sizeMod}px solid ${block.stroke}`, right: (4*sizeMod)+'px' });
                for(let i=0; i<3; i++) drawShape({ width: (18*sizeMod)+'px', height: (4*sizeMod)+'px', background: block.color, border: `${sizeMod}px solid ${block.stroke}`, top: (6 + i*10)*sizeMod + 'px', left: '50%', transform: 'translateX(-50%)' });
            } else if (block.type?.includes('bucket')) {
                drawShape({ width: (22*sizeMod)+'px', height: (18*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, clipPath: 'polygon(0% 0%, 100% 0%, 80% 100%, 20% 100%)', top: (10*sizeMod)+'px' });
                if (block.type === 'bucket_water') drawShape({ width: (16*sizeMod)+'px', height: (8*sizeMod)+'px', background: '#0f5e9c', top: (12*sizeMod)+'px', left: (7*sizeMod)+'px' });
                if (block.type === 'bucket_lava') drawShape({ width: (16*sizeMod)+'px', height: (8*sizeMod)+'px', background: '#ff5722', top: (12*sizeMod)+'px', left: (7*sizeMod)+'px' });
            } else if (block.toolType) {
                drawShape({ width: (4*sizeMod)+'px', height: (24*sizeMod)+'px', background: '#5c3b1e', transform: 'rotate(-45deg)' });
                if (block.toolType === 'pickaxe') drawShape({ width: (28*sizeMod)+'px', height: (8*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, top: (4*sizeMod)+'px' });
                else if (block.toolType === 'shovel') drawShape({ width: (14*sizeMod)+'px', height: (14*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, top: (2*sizeMod)+'px', borderRadius: '50%' });
                else if (block.toolType === 'axe') drawShape({ width: (18*sizeMod)+'px', height: (18*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, top: (2*sizeMod)+'px', left: (4*sizeMod)+'px' });
            } else if (id === 15) {
                drawShape({ width: (4*sizeMod)+'px', height: (24*sizeMod)+'px', background: '#5c3b1e', transform: 'rotate(-45deg)' });
            } else if (block.item) {
                drawShape({ width: (20*sizeMod)+'px', height: (20*sizeMod)+'px', backgroundColor: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, borderRadius: '50%' });
            } else {
                drawShape({ width: (30*sizeMod)+'px', height: (30*sizeMod)+'px', backgroundColor: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, borderRadius: '2px' });
                if (block.ore) {
                    for(let i=0; i<3; i++) drawShape({ width: (6*sizeMod)+'px', height: (6*sizeMod)+'px', background: block.ore, left: (Math.random()*20*sizeMod)+'px', top: (Math.random()*20*sizeMod)+'px' });
                }
            }
            if (count > 1) { 
                const cnt = document.createElement('div'); cnt.className = 'item-count'; cnt.innerText = count; container.appendChild(cnt); 
            }
            return container;
        }

        function handleSlotClick(type, idx, button) {
            if (type === 'creative') {
                const itemId = idx; const block = BLOCK_TYPES[itemId];
                const stackSize = (block.item || block.toolType || block.type?.includes('armor') || block.type?.includes('bucket')) ? 1 : 64;
                heldItem = { id: itemId, count: (button === 0 ? stackSize : 1) };
                updateHeldItemCursor(); return;
            }

            let targetArray;
            if (type === 'main') targetArray = mainInventory;
            else if (type === 'hotbar') targetArray = hotbarInventory;
            else if (type === 'craft2') targetArray = craftingGrid2x2;
            else if (type === 'craft3') targetArray = craftingGrid3x3;
            else if (type.startsWith('furnace-')) {
                const f = tileEntities[currentDimension][activeFurnacePos];
                if (!f) return;
                const field = type.replace('furnace-', '');
                const current = f[field];
                
                if (button === 0) {
                    if (!heldItem && current) { heldItem = { ...current }; f[field] = null; }
                    else if (heldItem && !current) { 
                        if (field === 'fuel' && !FUEL_VALUES[heldItem.id]) return;
                        if (field === 'input' && !SMELTING_RECIPES[heldItem.id]) return;
                        if (field === 'output') return;
                        f[field] = { ...heldItem }; heldItem = null; 
                    }
                    else if (heldItem && current && heldItem.id === current.id) { 
                        current.count += heldItem.count; heldItem = null; 
                    }
                }
                renderInventory(); updateHeldItemCursor(); return;
            }

            if (!targetArray || (player.gameMode === 'creative' && type === 'main')) return;

            const current = targetArray[idx];
            if (button === 0) {
                if (!heldItem && current) { heldItem = { ...current }; targetArray[idx] = null; }
                else if (heldItem && !current) { targetArray[idx] = { ...heldItem }; heldItem = null; }
                else if (heldItem && current) { 
                    if (heldItem.id === current.id) { current.count += heldItem.count; heldItem = null; }
                    else { const temp = { ...current }; targetArray[idx] = { ...heldItem }; heldItem = temp; } 
                }
            } else if (button === 2) {
                if (heldItem) { 
                    if (!current) { targetArray[idx] = { id: heldItem.id, count: 1 }; heldItem.count--; }
                    else if (current.id === heldItem.id) { current.count++; heldItem.count--; } 
                    if (heldItem.count <= 0) heldItem = null; 
                } else if (current) { 
                    const take = Math.ceil(current.count / 2); heldItem = { id: current.id, count: take }; 
                    current.count -= take; if (current.count <= 0) targetArray[idx] = null; 
                }
            }
            updateHeldItemCursor(); renderInventory();
        }

        function handleCraftingOutputClick() {
            if (craftingOutput && activeRecipeMatch && (!heldItem || heldItem.id === craftingOutput.id)) {
                if (!heldItem) heldItem = { ...craftingOutput }; else heldItem.count += craftingOutput.count;
                const grid = isUsingTable ? craftingGrid3x3 : craftingGrid2x2;
                const match = activeRecipeMatch; const recipe = match.recipe;
                const gridWidth = isUsingTable ? 3 : 2;
                for (let r = 0; r < recipe.pattern.length; r++) {
                    for (let c = 0; c < recipe.pattern[r].length; c++) {
                        const ingId = recipe.pattern[r][c];
                        if (ingId !== null) {
                            const gridIdx = (r + match.offsetY) * gridWidth + (c + match.offsetX);
                            grid[gridIdx].count--; if (grid[gridIdx].count <= 0) grid[gridIdx] = null;
                        }
                    }
                }
                renderInventory();
            }
        }

        function checkRecipes() {
            const grid = isUsingTable ? craftingGrid3x3 : craftingGrid2x2;
            const gridWidth = isUsingTable ? 3 : 2; const gridHeight = isUsingTable ? 3 : 2;
            let minX = gridWidth, maxX = -1, minY = gridHeight, maxY = -1;
            let totalItems = 0;
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const item = grid[y * gridWidth + x];
                    if (item) { minX = Math.min(minX, x); maxX = Math.max(maxX, x); minY = Math.min(minY, y); maxY = Math.max(maxY, y); totalItems++; }
                }
            }
            if (totalItems === 0) { craftingOutput = null; activeRecipeMatch = null; return; }
            const subWidth = maxX - minX + 1; const subHeight = maxY - minY + 1;
            const subGrid = [];
            for (let y = 0; y < subHeight; y++) {
                subGrid[y] = [];
                for (let x = 0; x < subWidth; x++) {
                    const item = grid[(y + minY) * gridWidth + (x + minX)]; subGrid[y][x] = item ? item.id : null;
                }
            }
            let bestMatch = null;
            for (const recipe of RECIPES) {
                const p = recipe.pattern;
                if (subWidth !== p[0].length || subHeight !== p.length) continue;
                let matches = true;
                for (let r = 0; r < p.length; r++) {
                    for (let c = 0; c < p[r].length; c++) if (subGrid[r][c] !== p[r][c]) { matches = false; break; }
                    if (!matches) break;
                }
                if (matches) { bestMatch = { recipe, offsetX: minX, offsetY: minY }; break; }
            }
            if (bestMatch) { craftingOutput = { id: bestMatch.recipe.result, count: bestMatch.recipe.amount }; activeRecipeMatch = bestMatch; } 
            else { craftingOutput = null; activeRecipeMatch = null; }
        }

        function updateHeldItemCursor() {
            const cursor = document.getElementById('held-item-cursor');
            if (heldItem) { 
                cursor.style.display = 'block'; cursor.style.left = (mouse.x + 12) + 'px'; cursor.style.top = (mouse.y + 12) + 'px'; 
                cursor.innerHTML = ''; cursor.appendChild(createItemVisual(heldItem.id, heldItem.count)); 
            } else cursor.style.display = 'none';
        }

        const TIER_NAMES = ["Hand", "Wood", "Stone", "Iron", "Diamond"];
        function updateTooltip() {
            let tooltipText = "";
            let subText = "";
            const el = document.elementFromPoint(mouse.x, mouse.y);
            const invSlot = el?.closest('.mc-slot');
            const hudSlot = el?.closest('.hud-slot');

            if (invSlot) {
                const type = invSlot.dataset.type; const idx = parseInt(invSlot.dataset.idx);
                let item = null;
                if (type === 'main') item = mainInventory[idx];
                else if (type === 'hotbar') item = hotbarInventory[idx];
                else if (type === 'craft2') item = craftingGrid2x2[idx];
                else if (type === 'craft3') item = craftingGrid3x3[idx];
                else if (type.startsWith('furnace-')) {
                    const f = tileEntities[currentDimension][activeFurnacePos];
                    if (f) item = f[type.replace('furnace-', '')];
                }
                else if (type === 'creative') item = { id: parseInt(invSlot.dataset.itemId) };
                else if (invSlot.id === 'crafting-output') item = craftingOutput;
                if (item) tooltipText = BLOCK_TYPES[item.id]?.name || "";
            } else if (hudSlot) {
                const slots = Array.from(document.querySelectorAll('.hud-slot'));
                const idx = slots.indexOf(hudSlot);
                const item = hotbarInventory[idx];
                if (item) tooltipText = BLOCK_TYPES[item.id]?.name || "";
            } else if (!inventoryOpen && !isPaused) {
                const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
                const wy = Math.floor((mouse.y + camera.y) / TILE_SIZE);
                const blockId = worlds[currentDimension][`${wx},${wy}`];
                if (blockId) {
                    const block = BLOCK_TYPES[blockId];
                    tooltipText = block.name;
                    if (block.requiredTier) {
                        const activeItem = hotbarInventory[activeHotbarIndex];
                        const tool = activeItem ? BLOCK_TYPES[activeItem.id] : null;
                        const hasRequired = (tool?.toolType === block.tool && tool?.tier >= block.requiredTier);
                        if (!hasRequired && player.gameMode !== 'creative') {
                            subText = `\nREQUIRES: ${TIER_NAMES[block.requiredTier]} ${block.tool.toUpperCase()}`;
                        }
                    }
                }
            }
            if (tooltipText) {
                itemTooltipEl.innerText = tooltipText + subText; 
                itemTooltipEl.style.display = 'block';
                itemTooltipEl.style.color = subText ? '#ff4d4d' : '#fff';
                itemTooltipEl.style.left = (mouse.x + 20) + 'px'; itemTooltipEl.style.top = (mouse.y - 40) + 'px';
            } else itemTooltipEl.style.display = 'none';
        }

        function addItemToInventory(id, count) {
            const lists = [hotbarInventory, mainInventory];
            for (const list of lists) { for (let i = 0; i < list.length; i++) if (list[i] && list[i].id === id) { list[i].count += count; return true; } }
            for (const list of lists) { for (let i = 0; i < list.length; i++) if (!list[i]) { list[i] = { id, count }; return true; } }
            return false;
        }

        function handleWorldInteraction() {
            if (player.dead || inventoryOpen || isPaused) return;
            const world = worlds[currentDimension];
            const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
            const wy = Math.floor((mouse.y + camera.y) / TILE_SIZE);
            if (wx < 0 || wx >= WORLD_WIDTH || wy < 0 || wy >= WORLD_HEIGHT) return;
            const key = `${wx},${wy}`;
            
            if (mouse.rightDown) {
                const activeItem = hotbarInventory[activeHotbarIndex];
                const block = BLOCK_TYPES[world[key]];
                
                if (block?.table) { toggleInventory(true); return; }
                if (block?.furnace) { 
                    if (!tileEntities[currentDimension][key]) {
                        tileEntities[currentDimension][key] = { input: null, fuel: null, output: null, burnTime: 0, maxBurnTime: 0, cookProgress: 0 };
                    }
                    toggleInventory(false, key); return; 
                }

                if (activeItem && activeItem.id === 64) {
                    if (world[key] === 63) { delete world[key]; activeItem.count--; if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; addItemToInventory(65, 1); updateHUD(); return; }
                    else if (world[key] === 6) { delete world[key]; activeItem.count--; if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; addItemToInventory(66, 1); updateHUD(); return; }
                }
                if (activeItem && (activeItem.id === 65 || activeItem.id === 66)) {
                    if (!world[key] || BLOCK_TYPES[world[key]]?.fluid) { world[key] = (activeItem.id === 65 ? 63 : 6); activeItem.count--; if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; addItemToInventory(64, 1); updateHUD(); return; }
                }
                if (activeItem && activeItem.id === 59 && world[key] === 28) { tryIgnitePortal(wx, wy); return; }
                if (activeItem && (!world[key] || BLOCK_TYPES[world[key]]?.fluid) && !BLOCK_TYPES[activeItem.id].item) {
                    const rect = { x: wx * TILE_SIZE, y: wy * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE };
                    if (!checkOverlap(player, rect)) { 
                        world[key] = activeItem.id;
                        if (player.gameMode !== 'creative') { activeItem.count--; if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; }
                        updateHUD(); 
                    }
                }
            }
        }

        function tryIgnitePortal(wx, wy) {
            const world = worlds[currentDimension];
            for(let sx = wx - 4; sx <= wx + 4; sx++) {
                for(let sy = wy - 5; sy <= wy + 5; sy++) {
                    if(world[`${sx},${sy}`] === 28 && world[`${sx+3},${sy}`] === 28) {
                        let isFrame = true;
                        for(let x=0; x<4; x++) if(world[`${sx+x},${sy}`] !== 28 || world[`${sx+x},${sy+4}`] !== 28) isFrame = false;
                        for(let y=0; y<5; y++) if(world[`${sx},${sy+y}`] !== 28 || world[`${sx+3},${sy+y}`] !== 28) isFrame = false;
                        if(isFrame) { for(let x=1; x<=2; x++) for(let y=1; y<=3; y++) world[`${sx+x},${sy+y}`] = 60; createParticles((sx+1.5)*TILE_SIZE, (sy+2)*TILE_SIZE, '#6a1b9a', 20); return; }
                    }
                }
            }
        }

        function updateHUD() {
            const hud = document.getElementById('hotbar-hud'); hud.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const item = hotbarInventory[i]; const slot = document.createElement('div');
                slot.className = `hud-slot ${activeHotbarIndex === i ? 'active' : ''}`;
                if (item) slot.appendChild(createItemVisual(item.id, item.count)); hud.appendChild(slot);
            }
            document.getElementById('dim-indicator').innerText = currentDimension === 'overworld' ? 'Overworld' : 'The Nether';
            document.getElementById('dim-indicator').style.color = currentDimension === 'overworld' ? '#ffb6c1' : '#ff4d4d';
            document.getElementById('mode-indicator').innerText = player.gameMode === 'creative' ? 'Creative Mode' : 'Survival Mode';
            document.getElementById('mode-indicator').style.color = player.gameMode === 'creative' ? '#f1c40f' : '#aaa';
            heartsContainer.style.display = player.gameMode === 'creative' ? 'none' : 'flex';
        }

        function updateHeartsUI() { 
            heartsContainer.innerHTML = ''; 
            for(let i=0; i<MAX_HEALTH; i++) { 
                const heart = document.createElement('div'); heart.className = `heart ${i >= player.health ? 'empty' : ''}`; 
                heartsContainer.appendChild(heart); 
            } 
        }

        function generateOverworld() {
            const world = worlds.overworld; const seed = Math.random() * 1000;
            const seaLevel = 45;
            for (let x = 0; x < WORLD_WIDTH; x++) {
                const surfaceY = Math.floor(Math.sin(x * 0.05 + seed) * 8 + 40);
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    let type = 0;
                    if (y === WORLD_HEIGHT - 1) type = 29;
                    else if (y > surfaceY) {
                        type = 2; // Dirt
                        if (y > surfaceY + 3) type = 3; // Stone
                        if (y > surfaceY + 12 && Math.random() < 0.1) type = 13; // Ores
                        if (y > surfaceY + 15 && Math.random() < 0.05) type = 14; // Iron
                    } else if (y >= seaLevel && !world[`${x},${y}`]) type = 63;
                    if (type) world[`${x},${y}`] = type;
                }
                for(let y=0; y<WORLD_HEIGHT; y++) {
                    const k = `${x},${y}`;
                    if(world[k] === 2 && !world[`${x},${y-1}`]) { world[k] = 1; if (Math.random() < 0.1) spawnTree(x, y - 1); break; }
                }
            }
        }

        function spawnTree(x, y) {
            const world = worlds.overworld;
            const height = 4 + Math.floor(Math.random() * 2);
            for(let i=0; i<height; i++) { const logK = `${x},${y-i}`; if(!world[logK]) world[logK] = 4; }
            for(let lx=-2; lx<=2; lx++) for(let ly=-2; ly<=0; ly++) { const leafK = `${x+lx},${y-height+ly}`; if(!world[leafK] && Math.abs(lx) + Math.abs(ly) < 4) world[leafK] = 5; }
        }

        function generateNether() {
            const world = worlds.nether; const seed = Math.random() * 2000;
            for (let x = 0; x < WORLD_WIDTH; x++) {
                for(let y=0; y<5; y++) world[`${x},${y}`] = 51;
                for(let y=WORLD_HEIGHT-5; y<WORLD_HEIGHT; y++) world[`${x},${y}`] = 51;
                for(let y=WORLD_HEIGHT-10; y<WORLD_HEIGHT-5; y++) world[`${x},${y}`] = 6;
                for (let y = 10; y < WORLD_HEIGHT - 15; y++) { if (Math.sin(x * 0.1 + seed) * Math.cos(y * 0.1 + seed) > 0.4) world[`${x},${y}`] = 51; }
            }
        }

        function checkOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
        
        function takeDamage(amt) { if (player.gameMode === 'creative' || player.invuln > 0 || player.dead) return; player.health -= amt; player.invuln = INVULN_TIME; updateHeartsUI(); if (player.health <= 0) die(); player.vy = -18; }
        function die() { player.dead = true; document.getElementById('death-screen').style.display = 'flex'; saveGame(); }
        function respawn() { player.health = MAX_HEALTH; player.dead = false; currentDimension = 'overworld'; player.x = (WORLD_WIDTH/2) * TILE_SIZE; player.y = 0; let startY = 0; while(!worlds.overworld[`${Math.floor(player.x/TILE_SIZE)},${startY}`] && startY < WORLD_HEIGHT) startY++; player.y = (startY - 2) * TILE_SIZE; player.isFlying = false; updateHeartsUI(); updateHUD(); document.getElementById('death-screen').style.display = 'none'; saveGame(); }

        function getMiningSpeed() {
            if (player.gameMode === 'creative') return 9999;
            const activeItem = hotbarInventory[activeHotbarIndex];
            if (!miningTarget) return 1;
            const targetBlockId = worlds[currentDimension][miningTarget.key];
            if (!targetBlockId || targetBlockId === 6 || targetBlockId === 63) return 0; 
            const block = BLOCK_TYPES[targetBlockId]; if (block.id === 29) return 0;
            let speed = 1.0; const tool = activeItem ? BLOCK_TYPES[activeItem.id] : null;
            if (block.requiredTier && (!tool || tool.toolType !== block.tool || tool.tier < block.requiredTier)) return 0;
            if (tool && tool.toolType === block.tool) speed = 1.0 + (tool.tier * 2.5); else if (block.tool) speed = 0.3;
            return speed;
        }

        function loop(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = timestamp - lastTimestamp; lastTimestamp = timestamp;
            tickAccumulator += deltaTime;
            while (tickAccumulator >= TICK_TIME) { update(); tickAccumulator -= TICK_TIME; }
            draw(); requestAnimationFrame(loop);
        }

        let fluidTimer = 0;
        function update() {
            if (!gameStarted || player.dead || isPaused) return;
            if (player.invuln > 0) player.invuln--;
            const world = worlds[currentDimension];

            // Update Furnaces
            const furnaces = tileEntities[currentDimension];
            for (let pos in furnaces) {
                const f = furnaces[pos];
                if (!world[pos] || !BLOCK_TYPES[world[pos]].furnace) { delete furnaces[pos]; continue; }
                const recipe = SMELTING_RECIPES[f.input?.id];
                const canSmelt = recipe && (!f.output || (f.output.id === recipe.result && f.output.count < 64));
                if (f.burnTime > 0) {
                    f.burnTime--;
                    if (canSmelt) {
                        f.cookProgress++;
                        if (f.cookProgress >= recipe.time) {
                            f.cookProgress = 0;
                            f.input.count--; if (f.input.count <= 0) f.input = null;
                            if (!f.output) f.output = { id: recipe.result, count: 1 };
                            else f.output.count++;
                            if (activeFurnacePos === pos) renderInventory();
                        }
                    } else { f.cookProgress = 0; }
                }
                if (f.burnTime <= 0 && canSmelt && f.fuel) {
                    const fuelVal = FUEL_VALUES[f.fuel.id];
                    if (fuelVal) { f.burnTime = fuelVal; f.maxBurnTime = fuelVal; f.fuel.count--; if (f.fuel.count <= 0) f.fuel = null; if (activeFurnacePos === pos) renderInventory(); }
                }
                if (f.burnTime <= 0 && !canSmelt) f.cookProgress = 0;
                if (activeFurnacePos === pos && inventoryOpen) renderInventory();
            }

            if (inventoryOpen) return;

            fluidTimer++;
            if (fluidTimer >= 5) {
                fluidTimer = 0;
                const fluidKeys = Object.keys(world).filter(k => BLOCK_TYPES[world[k]]?.fluid);
                fluidKeys.sort((a, b) => b.split(',')[1] - a.split(',')[1]);
                for (const k of fluidKeys) {
                    const [wx, wy] = k.split(',').map(Number);
                    const selfType = world[k];
                    const belowKey = `${wx},${wy+1}`;
                    const targetBelow = world[belowKey];
                    const neighbors = [[wx, wy-1], [wx, wy+1], [wx-1, wy], [wx+1, wy]];
                    let transformed = false;
                    for (const [nx, ny] of neighbors) {
                        const neighborK = `${nx},${ny}`;
                        const neighborT = world[neighborK];
                        if (!neighborT) continue;
                        if ((selfType === 63 && neighborT === 6) || (selfType === 6 && neighborT === 63)) {
                            if (selfType === 63 && neighborK === belowKey) { world[neighborK] = 28; transformed = true; break; }
                            else if (selfType === 6 && k === `${nx},${ny+1}`) { world[k] = 28; transformed = true; break; }
                            else { if (selfType === 63) { delete world[k]; world[k] = 7; } else { delete world[neighborK]; world[neighborK] = 7; } transformed = true; break; }
                        }
                    }
                    if (transformed) continue;
                    if (wy + 1 < WORLD_HEIGHT && (!targetBelow || BLOCK_TYPES[targetBelow]?.fluid)) { if (!targetBelow) { delete world[k]; world[belowKey] = selfType; } } 
                    else if (wy + 1 < WORLD_HEIGHT) { const dirs = Math.random() < 0.5 ? [1, -1] : [-1, 1]; for (let d of dirs) { const sideKey = `${wx+d},${wy}`; if (wx+d >= 0 && wx+d < WORLD_WIDTH && !world[sideKey]) { delete world[k]; world[sideKey] = selfType; break; } } }
                }
            }

            particles = particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.6; p.life--; return p.life > 0; });
            const px = Math.floor((player.x + player.w/2) / TILE_SIZE); const py = Math.floor((player.y + player.h/2) / TILE_SIZE);
            if (world[`${px},${py}`] === 60) { teleportTimer++; portalOverlay.style.opacity = teleportTimer / 20; if (teleportTimer >= 20) { currentDimension = currentDimension === 'overworld' ? 'nether' : 'overworld'; teleportTimer = 0; portalOverlay.style.opacity = 0; const targetWorld = worlds[currentDimension]; let found = false; for(let x=0; x<WORLD_WIDTH && !found; x++) for(let y=0; y<WORLD_HEIGHT && !found; y++) if(targetWorld[`${x},${y}`] === 60) { player.x = x * TILE_SIZE; player.y = (y-1) * TILE_SIZE; found = true; } if(!found) { player.x = (WORLD_WIDTH/2) * TILE_SIZE; let startY = 0; while(!targetWorld[`${Math.floor(player.x/TILE_SIZE)},${startY}`] && startY < WORLD_HEIGHT) startY++; player.y = (startY - 2) * TILE_SIZE; } updateHUD(); saveGame(); } } else { teleportTimer = 0; portalOverlay.style.opacity = 0; }
            if (mouse.down) { const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE); const wy = Math.floor((mouse.y + camera.y) / TILE_SIZE); const key = `${wx},${wy}`; const targetBlock = world[key]; if (targetBlock && !BLOCK_TYPES[targetBlock].fluid) { if (miningTarget?.key === key) { miningProgress += getMiningSpeed(); const block = BLOCK_TYPES[targetBlock]; if (Math.random() < 0.3 && getMiningSpeed() > 0) createParticles((wx+0.5)*TILE_SIZE, (wy+0.5)*TILE_SIZE, block.color, 1); if (miningProgress >= block.hardness) { if (player.gameMode !== 'creative') { addItemToInventory(block.drop || parseInt(targetBlock), 1); updateHUD(); } createParticles((wx+0.5)*TILE_SIZE, (wy+0.5)*TILE_SIZE, block.color, 8); delete world[key]; miningTarget = null; miningProgress = 0; } } else { miningTarget = { wx, wy, key }; miningProgress = 0; } } else { miningTarget = null; miningProgress = 0; } } else { miningTarget = null; miningProgress = 0; }
            let curSpeed = keys['shift'] ? SPRINT_SPEED : SPEED; if (player.isFlying) curSpeed *= 1.5; 
            const inFluid = BLOCK_TYPES[world[`${px},${py}`]]?.fluid;
            const isOnLadder = BLOCK_TYPES[world[`${px},${py}`]]?.ladder;

            if (inFluid) { curSpeed *= 0.4; if (keys['w'] || keys[' ']) player.vy = -6; else player.vy *= 0.8; if (world[`${px},${py}`] === 6) takeDamage(1.5); }
            
            if (keys['a'] || keys['arrowleft']) { player.vx -= curSpeed; player.facing = -1; player.animTimer += 0.8; } if (keys['d'] || keys['arrowright']) { player.vx += curSpeed; player.facing = 1; player.animTimer += 0.8; } player.vx *= FRICTION; player.x += player.vx; resolveCollision('x');
            
            if (isOnLadder) {
                player.vy = 4; // Auto descend
                if (keys['w'] || keys[' '] || keys['arrowup']) player.vy = -7; // Ascend
                player.vx *= 0.7; // Ladder friction
                player.grounded = true; // Allow jump off ladder if physics allows
            } else if (!player.isFlying && !inFluid) { 
                if ((keys['w'] || keys[' '] || keys['arrowup']) && player.grounded) { player.vy = JUMP; player.grounded = false; player.squash = 1.3; } player.vy += GRAVITY; 
            } else if (player.isFlying) { 
                if (keys['w'] || keys[' ']) player.vy = -20; else if (keys['s'] || keys['shift']) player.vy = 20; else player.vy *= 0.5; 
            }
            
            player.y += player.vy; player.squash += (1 - player.squash) * 0.45; player.grounded = false; if (player.y + player.h > WORLD_HEIGHT * TILE_SIZE) takeDamage(10); resolveCollision('y');
            camera.x += (player.x - width/2 - camera.x) * 0.35; camera.y += (player.y - height/2 - camera.y) * 0.35;
            document.getElementById('coords').innerText = `X: ${Math.floor(player.x/TILE_SIZE)} Y: ${Math.floor(player.y/TILE_SIZE)}`;
        }

        function resolveCollision(axis) {
            const world = worlds[currentDimension];
            const x1 = Math.floor(player.x / TILE_SIZE), x2 = Math.floor((player.x + player.w - 1) / TILE_SIZE);
            const y1 = Math.floor(player.y / TILE_SIZE), y2 = Math.floor((player.y + player.h - 1) / TILE_SIZE);
            for (let x = x1; x <= x2; x++) {
                for (let y = y1; y <= y2; y++) {
                    const type = world[`${x},${y}`];
                    if (type) { 
                        const block = BLOCK_TYPES[type]; 
                        if (block.hazard) { takeDamage(1); if (type === 6) continue; } 
                        if (block.teleport || block.fluid || block.ladder) continue; 
                        if (player.isFlying) continue; 
                        if (axis === 'x') { if (player.vx > 0) player.x = x * TILE_SIZE - player.w; else if (player.vx < 0) player.x = (x + 1) * TILE_SIZE; player.vx = 0; } else { if (player.vy > 0) { if (!player.grounded) player.squash = 0.7; player.y = y * TILE_SIZE - player.h; player.grounded = true; } else if (player.vy < 0) { player.y = (y + 1) * TILE_SIZE; } player.vy = 0; } 
                    }
                }
            }
        }

        function drawBlock(x, y, type, scale = 1, offsetX = 0, offsetY = 0, rot = 0) {
            const b = BLOCK_TYPES[type]; if(!b) return;
            const size = TILE_SIZE * scale;
            const tx = x * TILE_SIZE + offsetX; const ty = y * TILE_SIZE + offsetY; 
            const time = Date.now() / 300;
            const world = worlds[currentDimension];

            ctx.save();
            if (rot !== 0) { ctx.translate(tx + size/2, ty + size/2); ctx.rotate(rot); ctx.translate(-(tx + size/2), -(ty + size/2)); }
            ctx.fillStyle = b.color;
            if (b.animated) { if (type === 60) ctx.fillStyle = `hsl(${280 + Math.sin(time + x + y) * 30}, 70%, 30%)`; else if (type === 6 || type === 62) ctx.fillStyle = `hsl(${15 + Math.sin(time + x * 0.5) * 5}, 90%, ${40 + Math.sin(time + y) * 10}%)`; else if (type === 52) ctx.fillStyle = `hsl(50, 90%, ${70 + Math.sin(time) * 10}%)`; else if (type === 63) ctx.fillStyle = b.color; }
            
            if (b.texture === 'glass') { ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fillRect(tx, ty, size, size); ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 1; ctx.strokeRect(tx, ty, size, size); }
            else if (type === 35) { // Ladder draw
                ctx.fillStyle = b.color;
                ctx.fillRect(tx + size*0.1, ty, size*0.15, size);
                ctx.fillRect(tx + size*0.75, ty, size*0.15, size);
                for(let i=0; i<3; i++) ctx.fillRect(tx + size*0.1, ty + size*(0.2 + i*0.3), size*0.8, size*0.12);
                ctx.strokeStyle = b.stroke; ctx.lineWidth = 1;
                ctx.strokeRect(tx + size*0.1, ty, size*0.15, size);
                ctx.strokeRect(tx + size*0.75, ty, size*0.15, size);
            }
            else if (b.fluid && scale === 1) { const above = world[`${x},${y-1}`]; const isSubmerged = (above === type); if (isSubmerged) ctx.fillRect(tx, ty, size, size); else { ctx.fillRect(tx, ty + 6, size, size - 6); ctx.fillStyle = (type === 63 ? '#166fb8' : '#ff7043'); ctx.fillRect(tx, ty + 6 + Math.sin(time + x) * 2, size, 3); } } 
            else { ctx.fillRect(tx, ty, size, size); }

            if (type === 1) { ctx.fillStyle = b.topColor; ctx.fillRect(tx, ty, size, 8 * scale); ctx.fillRect(tx, ty + 8*scale, 4*scale, 4*scale); ctx.fillRect(tx+12*scale, ty+8*scale, 8*scale, 4*scale); ctx.fillRect(tx+28*scale, ty+8*scale, 6*scale, 4*scale); } 
            else if (b.texture === 'stone' || b.texture === 'cobble' || b.texture === 'netherrack' || b.texture === 'obsidian') { ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(tx+4*scale, ty+4*scale, 8*scale, 8*scale); ctx.fillRect(tx+20*scale, ty+18*scale, 12*scale, 12*scale); ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(tx+25*scale, ty+5*scale, 6*scale, 6*scale); ctx.fillRect(tx+8*scale, ty+25*scale, 10*scale, 10*scale); }
            if (b.ore) { ctx.fillStyle = b.ore; ctx.fillRect(tx+6*scale, ty+8*scale, 6*scale, 6*scale); ctx.fillRect(tx+24*scale, ty+14*scale, 8*scale, 8*scale); ctx.fillRect(tx+10*scale, ty+26*scale, 6*scale, 6*scale); }
            if (type === 67) { 
                ctx.fillStyle = '#333'; ctx.fillRect(tx + size*0.1, ty + size*0.1, size*0.8, size*0.3); 
                const f = tileEntities[currentDimension][`${x},${y}`];
                if (f && f.burnTime > 0) { ctx.fillStyle = '#ff5722'; ctx.fillRect(tx + size*0.15, ty + size*0.15, size*0.7, size*0.2); }
            }
            if (type === 11) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(tx + size/2, ty + size/2, size/2.5, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#333'; ctx.lineWidth = 2 * scale; ctx.beginPath(); ctx.moveTo(tx + size/2, ty + size/2); ctx.lineTo(tx + size/2 + Math.cos(time)*10*scale, ty + size/2 + Math.sin(time)*10*scale); ctx.stroke(); }
            if (!b.fluid && b.texture !== 'glass' && type !== 35) { ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 2 * scale; ctx.strokeRect(tx+1*scale, ty+1*scale, size-2*scale, size-2*scale); ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.strokeRect(tx, ty, size, size); }
            if (miningTarget?.wx === x && miningTarget?.wy === y && scale === 1) { const stage = Math.floor((miningProgress / b.hardness) * 5); if (stage > 0) { ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 3; for (let i = 0; i < stage; i++) { ctx.beginPath(); ctx.moveTo(tx+(i*8), ty); ctx.lineTo(tx+TILE_SIZE, ty+TILE_SIZE-(i*8)); ctx.stroke(); ctx.beginPath(); ctx.moveTo(tx, ty+(i*8)); ctx.lineTo(tx+TILE_SIZE-(i*8), ty+TILE_SIZE); ctx.stroke(); } } }
            ctx.restore();
        }

        function draw() {
            ctx.fillStyle = currentDimension === 'overworld' ? '#4a90e2' : '#1a0505'; ctx.fillRect(0, 0, width, height);
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            const world = worlds[currentDimension];
            if (world) { const v1 = Math.max(0, Math.floor(camera.x/TILE_SIZE)-1), v2 = Math.min(WORLD_WIDTH-1, Math.ceil((camera.x+width)/TILE_SIZE)+1), v3 = Math.max(0, Math.floor(camera.y/TILE_SIZE)-1), v4 = Math.min(WORLD_HEIGHT-1, Math.ceil((camera.y+height)/TILE_SIZE)+1); for (let x = v1; x <= v2; x++) for (let y = v3; y <= v4; y++) if (world[`${x},${y}`]) drawBlock(x, y, world[`${x},${y}`]); }
            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 50; ctx.fillRect(p.x, p.y, 6, 6); });
            ctx.globalAlpha = 1;
            if (!player.dead && player.invuln % 6 < 3) { ctx.save(); ctx.translate(player.x + player.w/2, player.y + player.h); ctx.scale(player.facing, player.squash); ctx.translate(-player.w/2, -player.h); ctx.fillStyle = '#ffb6c1'; ctx.fillRect(0, 4, player.w, player.h - 10); ctx.strokeStyle = '#ff69b4'; ctx.lineWidth = 2; ctx.strokeRect(0, 4, player.w, player.h - 10); ctx.fillRect(4, player.h - 8, 8, 8); ctx.fillRect(player.w - 12, player.h - 8, 8, 8); ctx.fillStyle = '#ff69b4'; ctx.fillRect(player.w - 6, 12, 10, 10); ctx.fillStyle = '#000'; ctx.fillRect(player.w - 10, 8, 4, 4); if (player.isFlying) { ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(-10, 10, 10, 5); ctx.fillRect(player.w, 10, 10, 5); } ctx.restore(); }
            ctx.restore();
        }
        init();
    </script>
</body>
</html>
