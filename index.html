
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Moinkcraft: Multiplayer Smelting & Crafting</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, push, onChildAdded, onChildChanged, onChildRemoved } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDXUJ2ooY5S_pR2liDGe-afRZhNo0RI8Zs",
            authDomain: "latinfroggame.firebaseapp.com",
            databaseURL: "https://latinfroggame-default-rtdb.firebaseio.com",
            projectId: "latinfroggame",
            storageBucket: "latinfroggame.firebasestorage.app",
            messagingSenderId: "196302891263",
            appId: "1:196302891263:web:0b2fd634738f890580c4ca",
            measurementId: "G-S5H91BQYMB"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        window.m_db = db;
        window.m_refs = { ref, set, onValue, update, push, onChildAdded, onChildChanged, onChildRemoved };
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press+Start+2P', cursive;
            background: #0d0d1a;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #4a90e2;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            image-rendering: pixelated;
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #title-screen {
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            text-align: center;
            padding: 20px;
            overflow-y: auto;
        }

        #mode-selection-overlay, #join-lan-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 210;
        }

        #pause-menu {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 150;
            text-align: center;
        }

        .floating-numbers {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }

        .time-particle {
            position: absolute;
            font-size: 20px;
            color: rgba(212, 175, 55, 0.2);
            animation: driftUp 10s linear infinite;
        }

        @keyframes driftUp {
            0% { transform: translateY(110vh) rotate(0deg); opacity: 0; }
            20% { opacity: 0.5; }
            80% { opacity: 0.5; }
            100% { transform: translateY(-10vh) rotate(360deg); opacity: 0; }
        }

        .hero-scene {
            position: relative;
            width: 160px;
            height: 180px;
            margin-bottom: 20px;
            z-index: 10;
        }

        .title-clock {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background: #f1c40f;
            border: 6px solid #b8860b;
            border-radius: 50%;
            box-shadow: 0 6px 0 #8b6b00, 0 10px 20px rgba(0,0,0,0.5);
        }

        .title-clock::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 3px; height: 25px;
            background: #333;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: translate(-50%, -100%) rotate(0deg); }
            to { transform: translate(-50%, -100%) rotate(360deg); }
        }

        .title-pig {
            position: absolute;
            width: 50px;
            height: 40px;
            background: #ffb6c1;
            bottom: 95px;
            left: 50%;
            margin-left: -25px;
            border-bottom: 4px solid #ff69b4;
            border-radius: 4px;
            animation: pigJump 1.2s cubic-bezier(0.45, 0, 0.55, 1) infinite;
        }

        .title-pig::before { content: ''; position: absolute; right: -6px; top: 18px; width: 10px; height: 14px; background: #ff69b4; border-right: 2px solid #c71585; border-radius: 2px; }
        .title-pig::after { content: ''; position: absolute; right: 10px; top: 10px; width: 6px; height: 6px; background: #000; box-shadow: -18px 0 0 #000; border-radius: 1px; }

        @keyframes pigJump {
            0%, 100% { transform: translateY(0) scaleY(1); }
            50% { transform: translateY(-80px) scaleY(1.1); }
            95% { transform: translateY(6px) scaleY(0.75); }
        }

        .game-title {
            font-size: 28px;
            color: #ffb6c1;
            text-shadow: 4px 4px 0px #c71585, 6px 6px 0px rgba(0,0,0,0.4);
            margin-bottom: 20px;
            letter-spacing: -2px;
            z-index: 10;
            position: relative;
        }

        .game-title span { color: #f1c40f; text-shadow: 4px 4px 0px #b8860b; }

        .worlds-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 400px;
            z-index: 10;
            padding: 10px;
        }

        .world-slot {
            background: #444;
            border: 4px solid;
            border-color: #666 #222 #222 #666;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .world-slot.empty { opacity: 0.7; }

        .world-info { text-align: left; flex: 1; }
        .world-name { font-size: 10px; color: #fff; margin-bottom: 6px; }
        .world-meta { font-size: 7px; color: #aaa; }

        .slot-actions { display: flex; gap: 8px; }

        .btn-mini { padding: 8px; font-size: 8px; background: #5b8a3e; border: 3px solid; border-color: #92c47c #2d451f #2d451f #92c47c; color: #fff; cursor: pointer; }
        .btn-mini.red { background: #b71c1c; border-color: #ef5350 #7f0000 #7f0000 #ef5350; }
        .btn-mini:hover { filter: brightness(1.2); }

        .hud-anchor {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: none;
            z-index: 50;
        }

        .hotbar-hud { display: flex; background: rgba(0, 0, 0, 0.6); padding: 4px; border: 4px solid #1a1a1a; pointer-events: auto; }
        .hud-slot { width: 52px; height: 52px; border: 4px solid transparent; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.05); position: relative; cursor: crosshair; }
        .hud-slot.active { border-color: #fff; background: rgba(255, 255, 255, 0.25); box-shadow: inset 0 0 10px rgba(255,255,255,0.5); }

        #inventory-screen { position: absolute; inset: 0; background: rgba(0, 0, 0, 0.7); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
        .mc-container { background: #c6c6c6; border: 6px solid; border-color: #eee #444 #444 #eee; padding: 20px; box-shadow: 8px 8px 0 rgba(0,0,0,0.6); display: flex; flex-direction: column; gap: 15px; position: relative; width: 600px; }
        .mc-label { color: #222; font-size: 9px; margin-bottom: 6px; font-weight: bold; }
        .mc-slot { width: 48px; height: 48px; background: #8b8b8b; border: 4px solid; border-color: #373737 #fefefe #fefefe #373737; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; }
        .mc-slot:hover { background: #aaa; box-shadow: inset 0 0 0 2px rgba(255,255,255,0.3); }
        .mc-slot.output { width: 56px; height: 56px; border-width: 5px; }
        .mc-grid { display: grid; gap: 4px; }
        #main-inventory-grid { max-height: 220px; overflow-y: auto; padding: 2px; }
        .top-section { display: flex; gap: 40px; align-items: flex-start; }
        .crafting-section { display: flex; align-items: center; gap: 20px; }
        .crafting-grid-2x2 { display: grid; grid-template-columns: repeat(2, 48px); gap: 4px; }
        .crafting-grid-3x3 { display: grid; grid-template-columns: repeat(3, 48px); gap: 4px; }
        .arrow-right { width: 34px; height: 24px; background: #444; clip-path: polygon(0% 20%, 60% 20%, 60% 0%, 100% 50%, 60% 100%, 60% 80%, 0% 80%); }
        .block-icon { width: 34px; height: 34px; pointer-events: none; position: relative; display: flex; align-items: center; justify-content: center; }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 11px; color: #fff; text-shadow: 2px 2px #000; font-weight: bold; pointer-events: none; z-index: 10; }
        #held-item-cursor { position: fixed; pointer-events: none; z-index: 1000; display: none; filter: drop-shadow(4px 4px 2px rgba(0,0,0,0.5)); }
        
        #item-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(16, 0, 16, 0.9);
            border: 2px solid #2d0a63;
            color: #fff;
            padding: 8px 12px;
            font-size: 8px;
            z-index: 2000;
            display: none;
            white-space: pre-wrap;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
            line-height: 1.4;
        }

        .status-ui { position: absolute; top: 25px; left: 25px; display: flex; flex-direction: column; gap: 12px; }
        .hearts { display: flex; gap: 6px; pointer-events: none; }
        .heart { width: 22px; height: 22px; background: #ff4d4d; border: 3px solid #7a0000; box-shadow: 3px 3px 0 rgba(0,0,0,0.3); border-radius: 4px; }
        .heart.empty { background: #222; border-color: #000; box-shadow: none; }
        #death-screen { position: absolute; inset: 0; background: rgba(30,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 101; }
        .btn { margin-top: 15px; padding: 15px 30px; background: #5b8a3e; border: 6px solid; border-color: #92c47c #2d451f #2d451f #92c47c; color: #fff; cursor: pointer; font-size: 12px; pointer-events: auto; text-align: center; box-shadow: 6px 6px 0 rgba(0,0,0,0.4); z-index: 10; transition: transform 0.1s; }
        .btn:hover { background: #6da34a; transform: scale(1.05); }
        .btn.grey { background: #888; border-color: #bbb #444 #444 #bbb; }
        .btn.gold { background: #f1c40f; border-color: #f9e79f #b8860b #b8860b #f9e79f; color: #333; }
        #portal-overlay {
            position: absolute;
            inset: 0;
            background: #4a148c;
            opacity: 0;
            z-index: 300;
            pointer-events: none;
            transition: opacity 1s;
        }
        #save-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            font-size: 8px;
            color: #76b052;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        #lan-code-display {
            background: #000;
            padding: 10px;
            color: #f1c40f;
            border: 2px dashed #f1c40f;
            margin-top: 20px;
            font-size: 14px;
            display: none;
        }

        input {
            background: #444;
            border: 4px solid #222;
            color: #fff;
            padding: 10px;
            font-family: 'Press+Start+2P', cursive;
            font-size: 10px;
            text-align: center;
            outline: none;
        }

        /* Furnace Specific Styles */
        .furnace-section { display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 20px; border: 4px solid #373737; background: #8b8b8b; }
        .furnace-main { display: flex; align-items: center; gap: 20px; }
        .furnace-fuel-area { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .furnace-flame { width: 28px; height: 28px; background: #444; clip-path: polygon(50% 0%, 80% 30%, 100% 70%, 100% 100%, 0% 100%, 0% 70%, 20% 30%); position: relative; }
        .furnace-flame.active { background: #ff5722; box-shadow: 0 0 10px #ff5722; animation: flicker 0.2s infinite; }
        .furnace-flame-inner { position: absolute; bottom: 0; width: 100%; background: #ffeb3b; }
        .cook-progress-arrow { width: 40px; height: 28px; background: #444; clip-path: polygon(0% 20%, 60% 20%, 60% 0%, 100% 50%, 60% 100%, 60% 80%, 0% 80%); position: relative; }
        .cook-progress-fill { position: absolute; left: 0; top: 0; height: 100%; background: #76b052; width: 0%; transition: width 0.1s linear; }

        @keyframes flicker {
            0% { opacity: 0.9; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0.9; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="portal-overlay"></div>
        <div id="held-item-cursor"></div>
        <div id="item-tooltip"></div>
        <div id="save-indicator">SAVING...</div>
        
        <div id="mode-selection-overlay">
            <h2 style="font-size: 20px; color: #fff; margin-bottom: 30px; text-shadow: 4px 4px #000;">SELECT GAME MODE</h2>
            <div style="display: flex; gap: 20px;">
                <div style="flex: 1; text-align: center;">
                    <div class="btn" style="width: 200px;" onclick="confirmNewWorld('survival')">SURVIVAL</div>
                </div>
                <div style="flex: 1; text-align: center;">
                    <div class="btn gold" style="width: 200px;" onclick="confirmNewWorld('creative')">CREATIVE</div>
                </div>
            </div>
            <div class="btn grey" style="margin-top: 40px; padding: 10px 20px;" onclick="closeModeSelection()">CANCEL</div>
        </div>

        <div id="join-lan-overlay">
            <h2 style="font-size: 16px; color: #fff; margin-bottom: 30px; text-shadow: 4px 4px #000;">ENTER JOIN CODE</h2>
            <input type="text" id="lan-input-code" placeholder="XXXXXX" maxlength="6">
            <div class="btn" style="width: 250px;" onclick="joinLanWorld()">CONNECT</div>
            <div class="btn grey" style="margin-top: 20px;" onclick="closeJoinLan()">BACK</div>
        </div>

        <div id="pause-menu">
            <h2 style="font-size: 24px; color: #fff; margin-bottom: 30px; text-shadow: 4px 4px #000;">GAME PAUSED</h2>
            <div class="btn" onclick="togglePauseMenu()">RESUME</div>
            <div class="btn gold" id="open-to-lan-btn" onclick="openToLan()">OPEN TO LAN</div>
            <div id="lan-code-display">CODE: <span id="code-val">------</span></div>
            <div class="btn grey" onclick="saveAndQuit()">SAVE AND QUIT</div>
        </div>

        <div id="title-screen">
            <div class="floating-numbers" id="floating-numbers"></div>
            <div class="hero-scene">
                <div class="title-pig"></div>
                <div class="title-clock"></div>
            </div>
            <h1 class="game-title">MOINK <span>O'CLOCK</span></h1>
            
            <div class="worlds-container" id="worlds-container">
                <div class="world-slot empty" id="slot-0">
                    <div class="world-info"><div class="world-name">SLOT 1</div><div class="world-meta">EMPTY</div></div>
                    <div class="slot-actions"><button class="btn-mini" onclick="handleSlotAction(0, 'play')">PLAY</button></div>
                </div>
                <div class="world-slot empty" id="slot-1">
                    <div class="world-info"><div class="world-name">SLOT 2</div><div class="world-meta">EMPTY</div></div>
                    <div class="slot-actions"><button class="btn-mini" onclick="handleSlotAction(1, 'play')">PLAY</button></div>
                </div>
                <div class="world-slot empty" id="slot-2">
                    <div class="world-info"><div class="world-name">SLOT 3</div><div class="world-meta">EMPTY</div></div>
                    <div class="slot-actions"><button class="btn-mini" onclick="handleSlotAction(2, 'play')">PLAY</button></div>
                </div>
            </div>

            <div class="btn gold" style="margin-top: 20px; width: 350px; font-size: 10px;" onclick="openJoinLan()">JOIN LAN WORLD</div>

            <div style="font-size: 6px; color: #555; margin-top: 20px;">ESC: PAUSE | WASD: MOVE | SPACE: JUMP | E: INV | CLICK: MINE/HIT</div>
        </div>
        <div class="ui-overlay">
            <div class="status-ui">
                <div id="coords" style="font-size: 10px; color: #fff; text-shadow: 2px 2px #000;">X: 0 Y: 0</div>
                <div id="dim-indicator" style="font-size: 10px; color: #ffb6c1; text-shadow: 2px 2px #000;">Overworld</div>
                <div id="time-indicator" style="font-size: 7px; color: #f1c40f;">12:00 PM</div>
                <div id="lan-indicator" style="font-size: 7px; color: #76b052; margin-top: 5px; display: none;">MULTIPLAYER ACTIVE</div>
            </div>
            <div class="hud-anchor">
                <div class="hearts" id="hearts-container"></div>
                <div class="hotbar-hud" id="hotbar-hud"></div>
            </div>
        </div>
        <div id="inventory-screen">
            <div class="mc-container" id="mc-inventory">
                <div class="top-section">
                    <div id="pig-preview" style="width: 100px; height: 120px; background: #8b8b8b; border: 4px solid #373737; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;">
                        <span style="font-size: 8px; color: #444; font-weight: bold;">PIGGY</span>
                        <div style="position: absolute; width: 40px; height: 30px; background: #ffb6c1; border: 2px solid #ff69b4; border-radius: 2px;">
                           <div style="position: absolute; right: 2px; top: 4px; width: 4px; height: 4px; background: #000;"></div>
                        </div>
                    </div>
                    
                    <div id="crafting-view">
                        <div class="mc-label" id="crafting-label">Crafting</div>
                        <div class="crafting-section">
                            <div class="crafting-grid-2x2" id="crafting-grid-2x2">
                                <div class="mc-slot" data-type="craft2" data-idx="0"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="1"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="2"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="3"></div>
                            </div>
                            <div class="crafting-grid-3x3" id="crafting-grid-3x3" style="display: none;">
                                <div class="mc-slot" data-type="craft3" data-idx="0"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="1"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="2"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="3"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="4"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="5"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="6"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="7"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="8"></div>
                            </div>
                            <div class="arrow-right"></div>
                            <div class="mc-slot output" id="crafting-output"></div>
                        </div>
                    </div>

                    <div id="furnace-view" style="display: none;">
                        <div class="mc-label">Furnace</div>
                        <div class="furnace-section">
                            <div class="furnace-main">
                                <div class="furnace-fuel-area">
                                    <div class="mc-slot" data-type="furnace-input" data-idx="0"></div>
                                    <div class="furnace-flame" id="furnace-flame"><div class="furnace-flame-inner" id="furnace-flame-inner"></div></div>
                                    <div class="mc-slot" data-type="furnace-fuel" data-idx="0"></div>
                                </div>
                                <div class="cook-progress-arrow">
                                    <div class="cook-progress-fill" id="cook-progress-fill"></div>
                                </div>
                                <div class="mc-slot output" data-type="furnace-output" data-idx="0"></div>
                            </div>
                        </div>
                    </div>

                </div>
                <div>
                    <div class="mc-label" id="inventory-label">Inventory</div>
                    <div class="mc-grid" style="grid-template-columns: repeat(9, 48px);" id="main-inventory-grid"></div>
                </div>
                <div style="margin-top: 8px;">
                    <div class="mc-grid" style="grid-template-columns: repeat(9, 48px);" id="hotbar-inventory-grid"></div>
                </div>
            </div>
        </div>
        <div id="death-screen">
            <h1 style="color: #ff4d4d; font-size: 24px; margin-bottom: 25px; text-shadow: 4px 4px #000;">YOU FAILED THE OINK</h1>
            <div class="btn" onclick="respawn()">START NEW CYCLE</div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 40;
        const TICKS_PER_SECOND = 20;
        const TICK_TIME = 1000 / TICKS_PER_SECOND;
        
        const GRAVITY = 1.8; 
        const FRICTION = 0.65; 
        const SPEED = 8.0; 
        const SPRINT_SPEED = 14.0; 
        const JUMP = -16; 
        const MAX_HEALTH = 10;
        const INVULN_TIME = 15; 
        const WORLD_WIDTH = 100;
        const WORLD_HEIGHT = 100;
        const DAY_LENGTH = 24000; 

        const BLOCK_TYPES = {
            1: { name: 'Grass', color: '#5b8a3e', stroke: '#3e5b2e', hardness: 10, tool: 'shovel', topColor: '#76b052' },
            2: { name: 'Dirt', color: '#7a5a3a', stroke: '#4d3a24', hardness: 12, tool: 'shovel' },
            3: { name: 'Stone', color: '#828282', stroke: '#555555', hardness: 50, tool: 'pickaxe', texture: 'stone', requiredTier: 1, drop: 7 },
            4: { name: 'Wood', color: '#6d4c41', stroke: '#3e2723', hardness: 30, tool: 'axe' },
            5: { name: 'Leaves', color: '#2e7d32', stroke: '#1b5e20', hardness: 5 },
            6: { name: 'Lava', color: '#ff5722', stroke: '#bf360c', hazard: true, hardness: 9999, animated: true, fluid: true, type: 'lava' },
            7: { name: 'Cobble', color: '#616161', stroke: '#424242', hardness: 45, tool: 'pickaxe', texture: 'cobble', requiredTier: 1 },
            8: { name: 'Sand', color: '#ffecb3', stroke: '#ffe082', hardness: 10, tool: 'shovel' },
            9: { name: 'Glass', color: 'rgba(200, 240, 255, 0.4)', stroke: '#fff', hardness: 5, texture: 'glass' },
            10: { name: 'Planks', color: '#d2b48c', stroke: '#8b4513', hardness: 25, tool: 'axe' },
            11: { name: 'Clock', color: '#fdd835', stroke: '#f9a825', special: true, hardness: 80, tool: 'pickaxe', requiredTier: 2 },
            12: { name: 'Crafting Table', color: '#795548', stroke: '#3e2723', hardness: 40, table: true, tool: 'axe' },
            13: { name: 'Coal Ore', color: '#828282', stroke: '#555555', hardness: 55, ore: '#212121', tool: 'pickaxe', drop: 30, requiredTier: 1 },
            14: { name: 'Iron Ore', color: '#828282', stroke: '#555555', hardness: 75, ore: '#d7ccc8', tool: 'pickaxe', drop: 14, requiredTier: 1 }, 
            15: { name: 'Stick', color: '#5d4037', stroke: '#3e2723', hardness: 10, item: true },
            16: { name: 'Wood Pickaxe', color: '#6d4c41', toolType: 'pickaxe', tier: 1, item: true },
            17: { name: 'Wood Shovel', color: '#6d4c41', toolType: 'shovel', tier: 1, item: true },
            18: { name: 'Wood Axe', color: '#6d4c41', toolType: 'axe', tier: 1, item: true },
            19: { name: 'Stone Pickaxe', color: '#616161', toolType: 'pickaxe', tier: 2, item: true },
            20: { name: 'Stone Shovel', color: '#616161', toolType: 'shovel', tier: 2, item: true },
            21: { name: 'Stone Axe', color: '#616161', toolType: 'axe', tier: 2, item: true },
            22: { name: 'Iron Pickaxe', color: '#e0e0e0', toolType: 'pickaxe', tier: 3, item: true },
            23: { name: 'Iron Shovel', color: '#e0e0e0', toolType: 'shovel', tier: 3, item: true },
            24: { name: 'Iron Axe', color: '#e0e0e0', toolType: 'axe', tier: 3, item: true },
            25: { name: 'Gold Ore', color: '#828282', stroke: '#555555', hardness: 80, ore: '#ffeb3b', tool: 'pickaxe', drop: 25, requiredTier: 1 },
            26: { name: 'Diamond Ore', color: '#828282', stroke: '#555555', hardness: 150, ore: '#00e5ff', tool: 'pickaxe', drop: 33, requiredTier: 3 },
            27: { name: 'Redstone Ore', color: '#828282', stroke: '#555555', hardness: 70, ore: '#ff1744', tool: 'pickaxe', drop: 34, requiredTier: 3 },
            28: { name: 'Obsidian', color: '#212121', stroke: '#1a1a1a', hardness: 600, tool: 'pickaxe', texture: 'obsidian', requiredTier: 4 },
            29: { name: 'Bedrock', color: '#1a1a1a', stroke: '#000000', hardness: 999999 },
            30: { name: 'Coal', color: '#212121', item: true, type: 'coal' },
            31: { name: 'Iron Ingot', color: '#f5f5f5', stroke: '#bdbdbd', item: true, type: 'ingot' },
            32: { name: 'Gold Ingot', color: '#fff176', stroke: '#fbc02d', item: true, type: 'ingot' },
            33: { name: 'Diamond', color: '#00e5ff', stroke: '#00b8d4', item: true, type: 'gem' },
            34: { name: 'Redstone Dust', color: '#ff1744', item: true, type: 'dust' },
            35: { name: 'Ladder', color: '#8d6e63', stroke: '#5d4037', hardness: 15, tool: 'axe', ladder: true },
            67: { name: 'Furnace', color: '#757575', stroke: '#424242', hardness: 50, tool: 'pickaxe', furnace: true },
            82: { name: 'Diamond Pickaxe', color: '#00e5ff', toolType: 'pickaxe', tier: 4, item: true },
            83: { name: 'Diamond Shovel', color: '#00e5ff', toolType: 'shovel', tier: 4, item: true },
            84: { name: 'Diamond Axe', color: '#00e5ff', toolType: 'axe', tier: 4, item: true },
            51: { name: 'Netherrack', color: '#b71c1c', stroke: '#7f0000', hardness: 15, tool: 'pickaxe', texture: 'netherrack', requiredTier: 1 },
            52: { name: 'Glowstone', color: '#fff59d', stroke: '#fbc02d', hardness: 10, animated: true },
            57: { name: 'Gravel', color: '#bdbdbd', stroke: '#9e9e9e', hardness: 10, tool: 'shovel', dropChance: 0.1, dropId: 58 },
            58: { name: 'Flint', color: '#424242', item: true },
            59: { name: 'Flint and Steel', color: '#e0e0e0', item: true, action: 'ignite' },
            60: { name: 'Nether Portal', color: '#6a1b9a', stroke: '#4a148c', hardness: 999, animated: true, teleport: true },
            63: { name: 'Water', color: '#0f5e9c', stroke: '#083d66', hardness: 9999, animated: true, fluid: true, type: 'water' },
            64: { name: 'Bucket', color: '#9e9e9e', stroke: '#616161', item: true, type: 'bucket' },
            65: { name: 'Water Bucket', color: '#9e9e9e', stroke: '#0f5e9c', item: true, type: 'bucket_water' },
            66: { name: 'Lava Bucket', color: '#9e9e9e', stroke: '#ff5722', item: true, type: 'bucket_lava' },
            70: { name: 'Rotten Pork', color: '#556b2f', item: true },
            71: { name: 'Fishing Rod', color: '#8d6e63', item: true, type: 'rod' },
            72: { name: 'Raw Fish', color: '#82b1ff', item: true, type: 'food', heal: 4 },
            73: { name: 'Clock-Wire', color: '#e0e0e0', item: true },
            74: { name: 'Raw Chimken', color: '#ffccbc', stroke: '#d84315', item: true, type: 'food', heal: 3 },
            75: { name: 'Feather', color: '#f5f5f5', stroke: '#e0e0e0', item: true },
            76: { name: 'Wood Sword', color: '#6d4c41', stroke: '#3e2723', item: true, toolType: 'sword', damage: 4 },
            77: { name: 'Stone Sword', color: '#616161', stroke: '#424242', item: true, toolType: 'sword', damage: 5 },
            78: { name: 'Iron Sword', color: '#e0e0e0', stroke: '#bdbdbd', item: true, toolType: 'sword', damage: 6 },
            79: { name: 'Gold Sword', color: '#fff176', stroke: '#fbc02d', item: true, toolType: 'sword', damage: 5 },
            80: { name: 'Diamond Sword', color: '#00e5ff', stroke: '#00b8d4', item: true, toolType: 'sword', damage: 8 },
            90: { name: 'End Portal', color: '#000', stroke: '#4a148c', hardness: 999, animated: true, teleport: true, toDimension: 'the_end' },
            91: { name: 'End Stone', color: '#fff9c4', stroke: '#fbc02d', hardness: 50, tool: 'pickaxe', texture: 'end_stone', requiredTier: 1 }
        };

        const MOB_TYPES = {
            'zombie_pig': { health: 10, speed: 3.5, behavior: 'chase', w: 34, h: 28, damage: 1, loot: 70, color: '#556b2f', stroke: '#3e4d22', hostile: true },
            'creeper_clock': { health: 8, speed: 4.5, behavior: 'explode', w: 24, h: 48, damage: 0, loot: 73, color: '#fdd835', stroke: '#f9a825', hostile: true },
            'chicken': { health: 4, speed: 2, behavior: 'wander', w: 20, h: 20, damage: 0, loot: 74, color: '#fff', stroke: '#ccc', hostile: false }
        };

        const RECIPES = [
            { pattern: [[4]], result: 10, amount: 4 },
            { pattern: [[10], [10]], result: 15, amount: 4 },
            { pattern: [[10, 10], [10, 10]], result: 12, amount: 1 },
            { pattern: [[15, null, 15], [15, 15, 15], [15, null, 15]], result: 35, amount: 3 },
            { pattern: [[7, 7, 7], [7, null, 7], [7, 7, 7]], result: 67, amount: 1 }, 
            { pattern: [[7, 7, 7], [null, 15, null], [null, 15, null]], result: 19, amount: 1 },
            { pattern: [[10, 10, 10], [null, 15, null], [null, 15, null]], result: 16, amount: 1 },
            { pattern: [[31, 31, 31], [null, 15, null], [null, 15, null]], result: 22, amount: 1 },
            { pattern: [[33, 33, 33], [null, 15, null], [null, 15, null]], result: 82, amount: 1 },
            { pattern: [[10], [15], [15]], result: 17, amount: 1 },
            { pattern: [[7], [15], [15]], result: 20, amount: 1 },
            { pattern: [[31], [15], [15]], result: 23, amount: 1 },
            { pattern: [[33], [15], [15]], result: 83, amount: 1 },
            { pattern: [[10, 10], [10, 15], [null, 15]], result: 18, amount: 1 },
            { pattern: [[7, 7], [7, 15], [null, 15]], result: 21, amount: 1 },
            { pattern: [[31, 31], [31, 15], [null, 15]], result: 24, amount: 1 },
            { pattern: [[33, 33], [33, 15], [null, 15]], result: 84, amount: 1 },
            { pattern: [[null, 32, null], [32, 34, 32], [null, 32, null]], result: 11, amount: 1 },
            { pattern: [[31, null, 31], [null, 31, null]], result: 64, amount: 1 },
            { pattern: [[58, 31]], result: 59, amount: 1 },
            { pattern: [[null, null, 15], [null, 15, 73], [15, null, 73]], result: 71, amount: 1 },
            { pattern: [[10], [10], [15]], result: 76, amount: 1 },
            { pattern: [[7], [7], [15]], result: 77, amount: 1 },
            { pattern: [[31], [31], [15]], result: 78, amount: 1 },
            { pattern: [[32], [32], [15]], result: 79, amount: 1 },
            { pattern: [[33], [33], [15]], result: 80, amount: 1 }
        ];

        const SMELTING_RECIPES = {
            7: { result: 3, time: 200 }, 
            14: { result: 31, time: 200 }, 
            25: { result: 32, time: 200 }, 
            8: { result: 9, time: 200 } 
        };

        const FUEL_VALUES = {
            30: 1600, 
            4: 300,   
            10: 300,  
            15: 100   
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const heartsContainer = document.getElementById('hearts-container');
        const portalOverlay = document.getElementById('portal-overlay');
        const saveIndicator = document.getElementById('save-indicator');
        const pauseMenuEl = document.getElementById('pause-menu');
        const modeSelectionEl = document.getElementById('mode-selection-overlay');
        const joinLanOverlay = document.getElementById('join-lan-overlay');
        const itemTooltipEl = document.getElementById('item-tooltip');
        const timeIndicatorEl = document.getElementById('time-indicator');
        
        let width, height;
        let camera = { x: 0, y: 0 };
        let gameTime = 6000; 
        let currentDimension = 'overworld';
        let worlds = { overworld: {}, nether: {}, the_end: {} };
        let tileEntities = { overworld: {}, nether: {}, the_end: {} };
        let mobs = { overworld: [], nether: [], the_end: [] };
        let teleportTimer = 0;
        let activeSaveSlot = null;
        let pendingSaveSlot = null;
        
        // Multiplayer State
        let lanSessionCode = null;
        let isLanHost = false;
        let isLanClient = false;
        let otherPlayers = {};
        let myPlayerId = Math.random().toString(36).substr(2, 9);

        let player = { 
            x: (WORLD_WIDTH / 2) * TILE_SIZE, 
            y: 0, 
            vx: 0, 
            vy: 0, 
            w: 34, 
            h: 28, 
            grounded: false, 
            health: MAX_HEALTH, 
            invuln: 0, 
            dead: false, 
            facing: 1,
            animTimer: 0,
            squash: 1,
            gameMode: 'survival', 
            isFlying: false,
            lastJumpTime: 0,
            fishing: { active: false, x: 0, y: 0, vx: 0, vy: 0, state: 'idle', timer: 0, biteTimer: 0 }
        };
        
        let mainInventory = new Array(27).fill(null);
        let hotbarInventory = new Array(9).fill(null);
        let craftingGrid2x2 = new Array(4).fill(null);
        let craftingGrid3x3 = new Array(9).fill(null);
        let craftingOutput = null;
        let activeRecipeMatch = null;
        let heldItem = null;

        let isUsingTable = false;
        let activeFurnacePos = null; 

        let miningTarget = null;
        let miningProgress = 0;
        let activeHotbarIndex = 0; 
        let inventoryOpen = false;
        let isPaused = false;
        let gameStarted = false;
        let keys = {};
        let mouse = { x: 0, y: 0, down: false, rightDown: false };
        let particles = [];

        let lastTimestamp = 0;
        let tickAccumulator = 0;

        function init() {
            resize();
            updateSlotsUI();
            setupInventoryUI();
            setupTitleParticles();

            window.addEventListener('resize', resize);
            window.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                if (!gameStarted) { keys[key] = true; return; }
                if (e.key === 'Escape') { if (inventoryOpen) toggleInventory(); else togglePauseMenu(); }
                if (!isPaused) {
                    if (key === 'e') toggleInventory();
                    if (!inventoryOpen && e.key >= '1' && e.key <= '9') { activeHotbarIndex = parseInt(e.key) - 1; updateHUD(); }
                    if (!inventoryOpen && (key === 'w' || key === ' ')) {
                        const now = Date.now();
                        if (player.gameMode === 'creative' && now - player.lastJumpTime < 300) { player.isFlying = !player.isFlying; player.vy = 0; }
                        player.lastJumpTime = now;
                    }
                }
                keys[key] = true;
            });
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            window.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top;
                if (gameStarted) { updateHeldItemCursor(); updateTooltip(); }
            });
            window.addEventListener('mousedown', e => {
                if (!gameStarted || isPaused) return;
                if (e.button === 0) { mouse.down = true; handleCombatInteraction(); }
                if (e.button === 2) { mouse.rightDown = true; if (!inventoryOpen) handleWorldInteraction(); }
            });
            window.addEventListener('mouseup', e => { if (e.button === 0) mouse.down = false; if (e.button === 2) mouse.rightDown = false; });
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            requestAnimationFrame(loop);
        }

        // Multiplayer Functions
        function openJoinLan() { joinLanOverlay.style.display = 'flex'; }
        function closeJoinLan() { joinLanOverlay.style.display = 'none'; }
        
        async function joinLanWorld() {
            const code = document.getElementById('lan-input-code').value.toUpperCase();
            if (code.length < 4) return;
            
            const { ref, onValue } = window.m_refs;
            const sessionRef = ref(window.m_db, `sessions/${code}`);
            
            onValue(sessionRef, (snapshot) => {
                const data = snapshot.val();
                if (!data) { alert("World not found!"); return; }
                
                // Initialize as client
                lanSessionCode = code;
                isLanClient = true;
                isLanHost = false;
                
                // Load host world and tile entity data
                worlds = data.world || { overworld: {}, nether: {}, the_end: {} };
                tileEntities = data.tileEntities || { overworld: {}, nether: {}, the_end: {} };
                gameTime = data.gameTime || 6000;
                
                closeJoinLan();
                startNewWorld('survival', true);
                startGame();
                
                document.getElementById('lan-indicator').style.display = 'block';
                document.getElementById('lan-indicator').innerText = "CONNECTED: " + code;
                
                setupMultiplayerListeners(code);
            }, { onlyOnce: true });
        }

        function openToLan() {
            if (lanSessionCode) return;
            const code = Math.random().toString(36).substr(2, 6).toUpperCase();
            lanSessionCode = code;
            isLanHost = true;
            isLanClient = false;

            const { ref, set } = window.m_refs;
            const sessionRef = ref(window.m_db, `sessions/${code}`);
            
            set(sessionRef, {
                world: worlds,
                tileEntities: tileEntities,
                gameTime: gameTime,
                hostId: myPlayerId
            });

            document.getElementById('lan-code-display').style.display = 'block';
            document.getElementById('code-val').innerText = code;
            document.getElementById('lan-indicator').style.display = 'block';
            document.getElementById('lan-indicator').innerText = "HOSTING: " + code;
            
            setupMultiplayerListeners(code);
        }

        function setupMultiplayerListeners(code) {
            const { ref, onChildAdded, onChildChanged, onChildRemoved, onValue } = window.m_refs;
            const playersRef = ref(window.m_db, `sessions/${code}/players`);
            const worldRef = ref(window.m_db, `sessions/${code}/world`);
            const tileRef = ref(window.m_db, `sessions/${code}/tileEntities`);

            onChildAdded(playersRef, (snapshot) => {
                if (snapshot.key !== myPlayerId) otherPlayers[snapshot.key] = snapshot.val();
            });
            onChildChanged(playersRef, (snapshot) => {
                if (snapshot.key !== myPlayerId) otherPlayers[snapshot.key] = snapshot.val();
            });
            onChildRemoved(playersRef, (snapshot) => {
                delete otherPlayers[snapshot.key];
            });

            onValue(worldRef, (snapshot) => {
                const remoteWorld = snapshot.val();
                if (remoteWorld) {
                    worlds.overworld = remoteWorld.overworld || {};
                    worlds.nether = remoteWorld.nether || {};
                    worlds.the_end = remoteWorld.the_end || {};
                }
            });

            onValue(tileRef, (snapshot) => {
                const remoteTiles = snapshot.val();
                if (remoteTiles) {
                    tileEntities.overworld = remoteTiles.overworld || {};
                    tileEntities.nether = remoteTiles.nether || {};
                    tileEntities.the_end = remoteTiles.the_end || {};
                }
            });
        }

        function syncMultiplayerData() {
            if (!lanSessionCode) return;
            const { ref, update } = window.m_refs;
            
            const myPlayerRef = ref(window.m_db, `sessions/${lanSessionCode}/players/${myPlayerId}`);
            update(myPlayerRef, {
                x: player.x,
                y: player.y,
                facing: player.facing,
                animTimer: player.animTimer,
                dim: currentDimension,
                id: myPlayerId
            });

            if (isLanHost) {
                const sessionRef = ref(window.m_db, `sessions/${lanSessionCode}`);
                update(sessionRef, { 
                    gameTime: gameTime,
                    tileEntities: tileEntities
                });
            }
        }

        function broadcastWorldChange() {
            if (!lanSessionCode) return;
            const { ref, update } = window.m_refs;
            const sessionRef = ref(window.m_db, `sessions/${lanSessionCode}`);
            update(sessionRef, {
                world: worlds,
                tileEntities: tileEntities
            });
        }

        function togglePauseMenu() {
            if (player.dead) return;
            isPaused = !isPaused;
            pauseMenuEl.style.display = isPaused ? 'flex' : 'none';
        }

        function saveAndQuit() {
            saveGame();
            isPaused = false; gameStarted = false;
            pauseMenuEl.style.display = 'none';
            document.getElementById('title-screen').style.display = 'flex';
            lanSessionCode = null; isLanHost = false; isLanClient = false; otherPlayers = {};
            document.getElementById('lan-indicator').style.display = 'none';
            updateSlotsUI();
        }

        function updateSlotsUI() {
            for (let i = 0; i < 3; i++) {
                const slotEl = document.getElementById(`slot-${i}`);
                const data = localStorage.getItem(`moinkcraft_world_${i}`);
                if (data) {
                    const parsed = JSON.parse(data);
                    slotEl.className = 'world-slot';
                    slotEl.querySelector('.world-meta').innerText = `SAVED: ${parsed.timestamp || 'N/A'}`;
                    slotEl.querySelector('.slot-actions').innerHTML = `<button class="btn-mini" onclick="handleSlotAction(${i}, 'play')">PLAY</button><button class="btn-mini red" onclick="handleSlotAction(${i}, 'delete')">X</button>`;
                } else {
                    slotEl.className = 'world-slot empty';
                    slotEl.querySelector('.world-meta').innerText = 'EMPTY';
                    slotEl.querySelector('.slot-actions').innerHTML = `<button class="btn-mini" onclick="handleSlotAction(${i}, 'play')">NEW</button>`;
                }
            }
        }

        function handleSlotAction(slot, action) {
            if (action === 'play') {
                const data = localStorage.getItem(`moinkcraft_world_${slot}`);
                if (data) { activeSaveSlot = slot; loadGame(JSON.parse(data)); startGame(); } 
                else { pendingSaveSlot = slot; modeSelectionEl.style.display = 'flex'; }
            } else if (action === 'delete') {
                if (confirm('DELETE WORLD FOREVER?')) { localStorage.removeItem(`moinkcraft_world_${slot}`); updateSlotsUI(); }
            }
        }

        function closeModeSelection() { modeSelectionEl.style.display = 'none'; pendingSaveSlot = null; }
        function confirmNewWorld(mode) { activeSaveSlot = pendingSaveSlot; pendingSaveSlot = null; modeSelectionEl.style.display = 'none'; startNewWorld(mode); startGame(); }

        function saveGame() {
            if (activeSaveSlot === null || player.dead || isLanClient) return;
            const saveData = {
                worlds, tileEntities, mobs,
                player: { x: player.x, y: player.y, health: player.health, dimension: currentDimension, gameMode: player.gameMode },
                inventory: { main: mainInventory, hotbar: hotbarInventory },
                gameTime: gameTime, timestamp: new Date().toLocaleString()
            };
            localStorage.setItem(`moinkcraft_world_${activeSaveSlot}`, JSON.stringify(saveData));
            showSaveIndicator();
        }

        function loadGame(data) {
            worlds = data.worlds; 
            tileEntities = data.tileEntities || { overworld: {}, nether: {}, the_end: {} };
            mobs = data.mobs || { overworld: [], nether: [], the_end: [] };
            player.x = data.player.x; player.y = data.player.y;
            player.health = data.player.health; player.gameMode = data.player.gameMode || 'survival';
            currentDimension = data.player.dimension || 'overworld';
            mainInventory = data.inventory.main; hotbarInventory = data.inventory.hotbar;
            gameTime = data.gameTime || 6000;
            player.isFlying = false; updateHUD(); updateHeartsUI(); 
        }

        function startNewWorld(mode = 'survival', fromJoin = false) {
            if (!fromJoin) {
                worlds = { overworld: {}, nether: {}, the_end: {} };
                tileEntities = { overworld: {}, nether: {}, the_end: {} };
                mobs = { overworld: [], nether: [], the_end: [] };
                gameTime = 6000; generateOverworld(); generateNether(); generateEnd();
            }
            mainInventory = new Array(27).fill(null); hotbarInventory = new Array(9).fill(null);
            const startX = Math.floor(WORLD_WIDTH / 2);
            let startY = 0;
            while(!worlds.overworld[`${startX},${startY}`] && startY < WORLD_HEIGHT) startY++;
            player.x = startX * TILE_SIZE; player.y = (startY - 2) * TILE_SIZE;
            player.health = MAX_HEALTH; player.gameMode = mode;
            currentDimension = 'overworld'; updateHUD(); updateHeartsUI(); if (!fromJoin) saveGame(); 
        }

        function showSaveIndicator() { saveIndicator.style.opacity = '1'; setTimeout(() => { saveIndicator.style.opacity = '0'; }, 2000); }
        function createParticles(x, y, color, count = 5) { for(let i=0; i<count; i++) { particles.push({ x, y, vx: (Math.random() - 0.5) * 5, vy: -Math.random() * 5, color, life: 30 + Math.random() * 20 }); } }
        function setupTitleParticles() { const container = document.getElementById('floating-numbers'); for(let i=0; i<15; i++) { const p = document.createElement('div'); p.className = 'time-particle'; p.innerText = Math.floor(Math.random() * 12) + 1; p.style.left = Math.random() * 100 + 'vw'; p.style.animationDelay = (Math.random() * 10) + 's'; p.style.fontSize = (Math.random() * 20 + 20) + 'px'; container.appendChild(p); } }
        function startGame() { gameStarted = true; isPaused = false; document.getElementById('title-screen').style.display = 'none'; }
        function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }

        function toggleInventory(useTable = false, furnacePos = null) {
            if (isPaused) return;
            inventoryOpen = !inventoryOpen; isUsingTable = useTable; activeFurnacePos = furnacePos;
            const screen = document.getElementById('inventory-screen'); screen.style.display = inventoryOpen ? 'flex' : 'none';
            const craftView = document.getElementById('crafting-view'); const furnaceView = document.getElementById('furnace-view');
            if (activeFurnacePos) { craftView.style.display = 'none'; furnaceView.style.display = 'block'; } else {
                craftView.style.display = 'block'; furnaceView.style.display = 'none';
                document.getElementById('crafting-grid-2x2').style.display = (isUsingTable || player.gameMode === 'creative') ? 'none' : 'grid';
                document.getElementById('crafting-grid-3x3').style.display = isUsingTable ? 'grid' : 'none';
                document.getElementById('pig-preview').style.display = (isUsingTable || player.gameMode === 'creative') ? 'none' : 'flex';
            }
            if (!inventoryOpen) {
                const returnItems = (grid) => { grid.forEach((item, i) => { if (item) addItemToInventory(item.id, item.count); grid[i] = null; }); };
                if (!activeFurnacePos) { returnItems(craftingGrid2x2); returnItems(craftingGrid3x3); }
                activeFurnacePos = null;
                if (heldItem && player.gameMode !== 'creative') { addItemToInventory(heldItem.id, heldItem.count); heldItem = null; }
                else if (heldItem) { heldItem = null; }
                updateHeldItemCursor(); saveGame();
            }
            itemTooltipEl.style.display = 'none'; renderInventory();
        }

        function setupInventoryUI() {
            const setupSlot = (slot) => { slot.addEventListener('mousedown', (e) => { const type = slot.dataset.type; const idx = parseInt(slot.dataset.idx); handleSlotClick(type, idx, e.button); e.preventDefault(); }); slot.addEventListener('contextmenu', (e) => e.preventDefault()); };
            const mainGrid = document.getElementById('main-inventory-grid'); mainGrid.innerHTML = '';
            for (let i = 0; i < 27; i++) { const slot = document.createElement('div'); slot.className = 'mc-slot'; slot.dataset.type = 'main'; slot.dataset.idx = i; setupSlot(slot); mainGrid.appendChild(slot); }
            const hbGrid = document.getElementById('hotbar-inventory-grid'); hbGrid.innerHTML = '';
            for (let i = 0; i < 9; i++) { const slot = document.createElement('div'); slot.className = 'mc-slot'; slot.dataset.type = 'hotbar'; slot.dataset.idx = i; setupSlot(slot); hbGrid.appendChild(slot); }
            document.querySelectorAll('#crafting-grid-2x2 .mc-slot').forEach(setupSlot);
            document.querySelectorAll('#crafting-grid-3x3 .mc-slot').forEach(setupSlot);
            document.querySelectorAll('#furnace-view .mc-slot').forEach(setupSlot);
            document.getElementById('crafting-output').addEventListener('mousedown', (e) => { if (e.button === 0) handleCraftingOutputClick(); });
        }

        function renderInventory() {
            const mainGrid = document.getElementById('main-inventory-grid');
            if (player.gameMode === 'creative' && !activeFurnacePos) {
                mainGrid.innerHTML = '';
                Object.keys(BLOCK_TYPES).forEach((id) => {
                    const slot = document.createElement('div'); slot.className = 'mc-slot'; slot.dataset.type = 'creative'; slot.dataset.itemId = id;
                    slot.appendChild(createItemVisual(parseInt(id), 1));
                    slot.addEventListener('mousedown', (e) => { handleSlotClick('creative', parseInt(id), e.button); e.preventDefault(); });
                    mainGrid.appendChild(slot);
                });
            } else {
                const slots = mainGrid.querySelectorAll('.mc-slot');
                mainInventory.forEach((item, i) => { const slot = slots[i]; if (!slot) return; slot.innerHTML = ''; if (item) slot.appendChild(createItemVisual(item.id, item.count)); });
            }
            const hbSlots = document.getElementById('hotbar-inventory-grid').querySelectorAll('.mc-slot');
            hotbarInventory.forEach((item, i) => { const slot = hbSlots[i]; if (!slot) return; slot.innerHTML = ''; if (item) slot.appendChild(createItemVisual(item.id, item.count)); });
            if (activeFurnacePos) {
                const f = tileEntities[currentDimension][activeFurnacePos];
                if (f) {
                    const slots = { 'furnace-input': f.input, 'furnace-fuel': f.fuel, 'furnace-output': f.output };
                    document.querySelectorAll('#furnace-view .mc-slot').forEach(slot => { const type = slot.dataset.type; slot.innerHTML = ''; if (slots[type]) slot.appendChild(createItemVisual(slots[type].id, slots[type].count)); });
                    const burnPercent = f.maxBurnTime > 0 ? (f.burnTime / f.maxBurnTime) * 100 : 0;
                    document.getElementById('furnace-flame-inner').style.height = burnPercent + '%';
                    document.getElementById('furnace-flame').className = f.burnTime > 0 ? 'furnace-flame active' : 'furnace-flame';
                    const cookTarget = SMELTING_RECIPES[f.input?.id]?.time || 200;
                    const cookPercent = (f.cookProgress / cookTarget) * 100;
                    document.getElementById('cook-progress-fill').style.width = cookPercent + '%';
                }
            } else {
                const craftSlots2 = document.querySelectorAll('#crafting-grid-2x2 .mc-slot');
                craftingGrid2x2.forEach((item, i) => { if(craftSlots2[i]) { craftSlots2[i].innerHTML = ''; if (item) craftSlots2[i].appendChild(createItemVisual(item.id, item.count)); } });
                const craftSlots3 = document.querySelectorAll('#crafting-grid-3x3 .mc-slot');
                craftingGrid3x3.forEach((item, i) => { if(craftSlots3[i]) { craftSlots3[i].innerHTML = ''; if (item) craftSlots3[i].appendChild(createItemVisual(item.id, item.count)); } });
                checkRecipes();
                const outputSlot = document.getElementById('crafting-output'); outputSlot.innerHTML = ''; if (craftingOutput) outputSlot.appendChild(createItemVisual(craftingOutput.id, craftingOutput.count));
            }
            updateHUD();
        }

        function createItemVisual(id, count, scale = 1) {
            const block = BLOCK_TYPES[id]; if (!block) return document.createElement('div');
            const container = document.createElement('div'); container.className = 'block-icon';
            const drawShape = (style) => { const div = document.createElement('div'); Object.assign(div.style, style, { position: 'absolute' }); container.appendChild(div); };
            const sizeMod = scale;
            if (block.toolType === 'sword') { drawShape({ width: (4*sizeMod)+'px', height: (10*sizeMod)+'px', background: '#5c3b1e', transform: 'rotate(-45deg)', bottom: '4px', left: '12px' }); drawShape({ width: (14*sizeMod)+'px', height: (4*sizeMod)+'px', background: '#333', transform: 'rotate(-45deg)', bottom: '12px', left: '10px' }); drawShape({ width: (8*sizeMod)+'px', height: (28*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, transform: 'rotate(-45deg)', top: '2px', left: '16px', borderRadius: '2px' }); }
            else if (id === 71) { drawShape({ width: (4*sizeMod)+'px', height: (34*sizeMod)+'px', background: '#8d6e63', transform: 'rotate(25deg)' }); drawShape({ width: (2*sizeMod)+'px', height: (20*sizeMod)+'px', background: '#fff', top: (5*sizeMod)+'px', left: (15*sizeMod)+'px' }); }
            else if (id === 72 || id === 74) { drawShape({ width: (24*sizeMod)+'px', height: (12*sizeMod)+'px', background: block.color, borderRadius: '50% 50% 20% 20%', border: `${2*sizeMod}px solid ${block.stroke || '#1a237e'}` }); drawShape({ width: (8*sizeMod)+'px', height: (8*sizeMod)+'px', background: block.color, transform: 'rotate(45deg)', left: (18*sizeMod)+'px', top: (2*sizeMod)+'px', border: `${2*sizeMod}px solid ${block.stroke || '#1a237e'}` }); }
            else if (id === 73) { drawShape({ width: (20*sizeMod)+'px', height: (20*sizeMod)+'px', background: 'transparent', border: `${2*sizeMod}px solid #fff`, borderRadius: '50%', clipPath: 'polygon(0% 0%, 100% 0%, 100% 50%, 0% 50%)' }); }
            else if (id === 75) { drawShape({ width: (8*sizeMod)+'px', height: (24*sizeMod)+'px', background: block.color, border: `${sizeMod}px solid ${block.stroke}`, transform: 'rotate(20deg)', borderRadius: '0 50% 0 50%' }); }
            else if (block.type === 'ingot') { drawShape({ width: (24*sizeMod)+'px', height: (12*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, transform: 'rotate(-25deg)', borderRadius: '2px' }); }
            else if (block.type === 'coal') { drawShape({ width: (18*sizeMod)+'px', height: (18*sizeMod)+'px', background: block.color, clipPath: 'polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)' }); }
            else if (block.type === 'gem') { drawShape({ width: (18*sizeMod)+'px', height: (18*sizeMod)+'px', background: block.color, clipPath: 'polygon(50% 0%, 100% 40%, 80% 100%, 20% 100%, 0% 40%)' }); }
            else if (block.texture === 'glass') { drawShape({ width: (30*sizeMod)+'px', height: (30*sizeMod)+'px', background: block.color, border: `2px solid #fff`, borderRadius: '2px' }); drawShape({ width: (10*sizeMod)+'px', height: (2*sizeMod)+'px', background: '#fff', top: '5px', left: '5px' }); }
            else if (id === 35) { drawShape({ width: (4*sizeMod)+'px', height: (34*sizeMod)+'px', background: block.color, border: `${sizeMod}px solid ${block.stroke}`, left: (4*sizeMod)+'px' }); drawShape({ width: (4*sizeMod)+'px', height: (34*sizeMod)+'px', background: block.color, border: `${sizeMod}px solid ${block.stroke}`, right: (4*sizeMod)+'px' }); for(let i=0; i<3; i++) drawShape({ width: (18*sizeMod)+'px', height: (4*sizeMod)+'px', background: block.color, border: `${sizeMod}px solid ${block.stroke}`, top: (6 + i*10)*sizeMod + 'px', left: '50%', transform: 'translateX(-50%)' }); }
            else if (block.type?.includes('bucket')) { drawShape({ width: (22*sizeMod)+'px', height: (18*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, clipPath: 'polygon(0% 0%, 100% 0%, 80% 100%, 20% 100%)', top: (10*sizeMod)+'px' }); if (block.type === 'bucket_water') drawShape({ width: (16*sizeMod)+'px', height: (8*sizeMod)+'px', background: '#0f5e9c', top: (12*sizeMod)+'px', left: (7*sizeMod)+'px' }); if (block.type === 'bucket_lava') drawShape({ width: (16*sizeMod)+'px', height: (8*sizeMod)+'px', background: '#ff5722', top: (12*sizeMod)+'px', left: (7*sizeMod)+'px' }); }
            else if (block.toolType) { drawShape({ width: (4*sizeMod)+'px', height: (24*sizeMod)+'px', background: '#5c3b1e', transform: 'rotate(-45deg)' }); if (block.toolType === 'pickaxe') drawShape({ width: (28*sizeMod)+'px', height: (8*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, top: (4*sizeMod)+'px' }); else if (block.toolType === 'shovel') drawShape({ width: (14*sizeMod)+'px', height: (14*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, top: (2*sizeMod)+'px', borderRadius: '50%' }); else if (block.toolType === 'axe') drawShape({ width: (18*sizeMod)+'px', height: (18*sizeMod)+'px', background: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, top: (2*sizeMod)+'px', left: (4*sizeMod)+'px' }); }
            else if (id === 15) { drawShape({ width: (4*sizeMod)+'px', height: (24*sizeMod)+'px', background: '#5c3b1e', transform: 'rotate(-45deg)' }); }
            else if (block.item) { drawShape({ width: (20*sizeMod)+'px', height: (20*sizeMod)+'px', backgroundColor: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, borderRadius: '50%' }); }
            else { drawShape({ width: (30*sizeMod)+'px', height: (30*sizeMod)+'px', backgroundColor: block.color, border: `${2*sizeMod}px solid ${block.stroke}`, borderRadius: '2px' }); if (block.ore) { for(let i=0; i<3; i++) drawShape({ width: (6*sizeMod)+'px', height: (6*sizeMod)+'px', background: block.ore, left: (Math.random()*20*sizeMod)+'px', top: (Math.random()*20*sizeMod)+'px' }); } }
            if (count > 1) { const cnt = document.createElement('div'); cnt.className = 'item-count'; cnt.innerText = count; container.appendChild(cnt); }
            return container;
        }

        function handleSlotClick(type, idx, button) {
            if (type === 'creative') {
                const itemId = idx; const block = BLOCK_TYPES[itemId];
                const stackSize = (block.item || block.toolType || block.type?.includes('bucket')) ? 1 : 64;
                heldItem = { id: itemId, count: (button === 0 ? stackSize : 1) };
                updateHeldItemCursor(); return;
            }
            let targetArray;
            if (type === 'main') targetArray = mainInventory; else if (type === 'hotbar') targetArray = hotbarInventory; else if (type === 'craft2') targetArray = craftingGrid2x2; else if (type === 'craft3') targetArray = craftingGrid3x3;
            else if (type.startsWith('furnace-')) {
                const f = tileEntities[currentDimension][activeFurnacePos]; if (!f) return;
                const field = type.replace('furnace-', ''); const current = f[field];
                if (button === 0) {
                    if (!heldItem && current) { heldItem = { ...current }; f[field] = null; }
                    else if (heldItem && !current) { if (field === 'fuel' && !FUEL_VALUES[heldItem.id]) return; if (field === 'input' && !SMELTING_RECIPES[heldItem.id]) return; if (field === 'output') return; f[field] = { ...heldItem }; heldItem = null; }
                    else if (heldItem && current && heldItem.id === current.id) { current.count += heldItem.count; heldItem = null; }
                }
                broadcastWorldChange(); renderInventory(); updateHeldItemCursor(); return;
            }
            if (!targetArray || (player.gameMode === 'creative' && type === 'main')) return;
            const current = targetArray[idx];
            if (button === 0) { if (!heldItem && current) { heldItem = { ...current }; targetArray[idx] = null; } else if (heldItem && !current) { targetArray[idx] = { ...heldItem }; heldItem = null; } else if (heldItem && current) { if (heldItem.id === current.id) { current.count += heldItem.count; heldItem = null; } else { const temp = { ...current }; targetArray[idx] = { ...heldItem }; heldItem = temp; } } }
            else if (button === 2) { if (heldItem) { if (!current) { targetArray[idx] = { id: heldItem.id, count: 1 }; heldItem.count--; } else if (current.id === heldItem.id) { current.count++; heldItem.count--; } if (heldItem.count <= 0) heldItem = null; } else if (current) { const take = Math.ceil(current.count / 2); heldItem = { id: current.id, count: take }; current.count -= take; if (current.count <= 0) targetArray[idx] = null; } }
            updateHeldItemCursor(); renderInventory();
        }

        function handleCraftingOutputClick() {
            if (craftingOutput && activeRecipeMatch && (!heldItem || heldItem.id === craftingOutput.id)) {
                if (!heldItem) heldItem = { ...craftingOutput }; else heldItem.count += craftingOutput.count;
                const grid = isUsingTable ? craftingGrid3x3 : craftingGrid2x2;
                const match = activeRecipeMatch; const recipe = match.recipe; const gridWidth = isUsingTable ? 3 : 2;
                for (let r = 0; r < recipe.pattern.length; r++) { for (let c = 0; c < recipe.pattern[r].length; c++) { const ingId = recipe.pattern[r][c]; if (ingId !== null) { const gridIdx = (r + match.offsetY) * gridWidth + (c + match.offsetX); grid[gridIdx].count--; if (grid[gridIdx].count <= 0) grid[gridIdx] = null; } } }
                renderInventory();
            }
        }

        function checkRecipes() {
            const grid = isUsingTable ? craftingGrid3x3 : craftingGrid2x2;
            const gridWidth = isUsingTable ? 3 : 2; const gridHeight = isUsingTable ? 3 : 2;
            let minX = gridWidth, maxX = -1, minY = gridHeight, maxY = -1, totalItems = 0;
            for (let y = 0; y < gridHeight; y++) { for (let x = 0; x < gridWidth; x++) { const item = grid[y * gridWidth + x]; if (item) { minX = Math.min(minX, x); maxX = Math.max(maxX, x); minY = Math.min(minY, y); maxY = Math.max(maxY, y); totalItems++; } } }
            if (totalItems === 0) { craftingOutput = null; activeRecipeMatch = null; return; }
            const subWidth = maxX - minX + 1, subHeight = maxY - minY + 1, subGrid = [];
            for (let y = 0; y < subHeight; y++) { subGrid[y] = []; for (let x = 0; x < subWidth; x++) { const item = grid[(y + minY) * gridWidth + (x + minX)]; subGrid[y][x] = item ? item.id : null; } }
            let bestMatch = null;
            for (const recipe of RECIPES) {
                const p = recipe.pattern; if (subWidth !== p[0].length || subHeight !== p.length) continue;
                let matches = true;
                for (let r = 0; r < p.length; r++) { for (let c = 0; c < p[r].length; c++) if (subGrid[r][c] !== p[r][c]) { matches = false; break; } if (!matches) break; }
                if (matches) { bestMatch = { recipe, offsetX: minX, offsetY: minY }; break; }
            }
            if (bestMatch) { craftingOutput = { id: bestMatch.recipe.result, count: bestMatch.recipe.amount }; activeRecipeMatch = bestMatch; } else { craftingOutput = null; activeRecipeMatch = null; }
        }

        function updateHeldItemCursor() { const cursor = document.getElementById('held-item-cursor'); if (heldItem) { cursor.style.display = 'block'; cursor.style.left = (mouse.x + 12) + 'px'; cursor.style.top = (mouse.y + 12) + 'px'; cursor.innerHTML = ''; cursor.appendChild(createItemVisual(heldItem.id, heldItem.count)); } else cursor.style.display = 'none'; }
        function updateTooltip() {
            let tooltipText = "", subText = "";
            const el = document.elementFromPoint(mouse.x, mouse.y);
            const invSlot = el?.closest('.mc-slot'); const hudSlot = el?.closest('.hud-slot');
            if (invSlot) {
                const type = invSlot.dataset.type, idx = parseInt(invSlot.dataset.idx); let item = null;
                if (type === 'main') item = mainInventory[idx]; else if (type === 'hotbar') item = hotbarInventory[idx]; else if (type === 'craft2') item = craftingGrid2x2[idx]; else if (type === 'craft3') item = craftingGrid3x3[idx]; else if (type.startsWith('furnace-')) { const f = tileEntities[currentDimension][activeFurnacePos]; if (f) item = f[type.replace('furnace-', '')]; } else if (type === 'creative') item = { id: parseInt(invSlot.dataset.itemId) }; else if (invSlot.id === 'crafting-output') item = craftingOutput;
                if (item) { const block = BLOCK_TYPES[item.id]; tooltipText = block?.name || ""; if (block?.toolType === 'sword') subText = `\nDAMAGE: ${block.damage}`; }
            } else if (hudSlot) {
                const slots = Array.from(document.querySelectorAll('.hud-slot')), idx = slots.indexOf(hudSlot), item = hotbarInventory[idx];
                if (item) { const block = BLOCK_TYPES[item.id]; tooltipText = block?.name || ""; if (block?.toolType === 'sword') subText = `\nDAMAGE: ${block.damage}`; }
            }
            if (tooltipText) { itemTooltipEl.innerText = tooltipText + subText; itemTooltipEl.style.display = 'block'; itemTooltipEl.style.color = subText.includes('DAMAGE') ? '#aaffaa' : '#fff'; itemTooltipEl.style.left = (mouse.x + 20) + 'px'; itemTooltipEl.style.top = (mouse.y - 40) + 'px'; } else itemTooltipEl.style.display = 'none';
        }

        function addItemToInventory(id, count) { const lists = [hotbarInventory, mainInventory]; for (const list of lists) { for (let i = 0; i < list.length; i++) if (list[i] && list[i].id === id) { list[i].count += count; return true; } } for (const list of lists) { for (let i = 0; i < list.length; i++) if (!list[i]) { list[i] = { id, count }; return true; } } return false; }
        function handleCombatInteraction() {
            if (player.dead || inventoryOpen || isPaused) return;
            const hitX = mouse.x + camera.x, hitY = mouse.y + camera.y, currentMobs = mobs[currentDimension], activeItem = hotbarInventory[activeHotbarIndex], blockData = activeItem ? BLOCK_TYPES[activeItem.id] : null;
            let damage = 2, knockback = 10; if (blockData?.toolType === 'sword') { damage = blockData.damage; knockback = 15 + (damage * 0.5); createParticles(hitX, hitY, blockData.color, 3); }
            for(let i = currentMobs.length - 1; i >= 0; i--) {
                const m = currentMobs[i];
                if(hitX >= m.x && hitX <= m.x + m.w && hitY >= m.y && hitY <= m.y + m.h) { const dist = Math.hypot(player.x + player.w/2 - hitX, player.y + player.h/2 - hitY); if(dist < 150) { m.health -= damage; m.vx = (m.x - player.x) > 0 ? knockback : -knockback; m.vy = -5; createParticles(m.x + m.w/2, m.y + m.h/2, '#ff0000', 10); if(m.health <= 0) { if(m.loot) addItemToInventory(m.loot, 1); if(m.type === 'chicken' && Math.random() < 0.7) { addItemToInventory(75, Math.floor(Math.random() * 2) + 1); } createParticles(m.x + m.w/2, m.y + m.h/2, m.color, 15); currentMobs.splice(i, 1); } return; } }
            }
        }

        function handleWorldInteraction() {
            if (player.dead || inventoryOpen || isPaused) return;
            const world = worlds[currentDimension], activeItem = hotbarInventory[activeHotbarIndex];
            if (activeItem?.id === 71) { if (!player.fishing.active) { player.fishing.active = true; player.fishing.x = player.x + player.w/2; player.fishing.y = player.y + player.h/2; player.fishing.vx = (player.facing * 12); player.fishing.vy = -10; player.fishing.state = 'casting'; } else { if (player.fishing.state === 'bite') { const roll = Math.random(); let loot = 72; if (roll < 0.1) loot = 32; else if (roll < 0.2) loot = 15; else if (roll < 0.3) loot = 34; addItemToInventory(loot, 1); createParticles(player.fishing.x, player.fishing.y, '#fff', 20); updateHUD(); } player.fishing.active = false; } return; }
            if (BLOCK_TYPES[activeItem?.id]?.type === 'food') { player.health = Math.min(MAX_HEALTH, player.health + (BLOCK_TYPES[activeItem.id].heal || 2)); activeItem.count--; if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; updateHeartsUI(); updateHUD(); createParticles(player.x + player.w/2, player.y + player.h/2, BLOCK_TYPES[activeItem.id].color, 5); return; }
            const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE), wy = Math.floor((mouse.y + camera.y) / TILE_SIZE);
            if (wx < 0 || wx >= WORLD_WIDTH || wy < 0 || wy >= WORLD_HEIGHT) return;
            const key = `${wx},${wy}`;
            if (mouse.rightDown) {
                const block = BLOCK_TYPES[world[key]];
                if (block?.table) { toggleInventory(true); return; }
                if (block?.furnace) { if (!tileEntities[currentDimension][key]) { tileEntities[currentDimension][key] = { input: null, fuel: null, output: null, burnTime: 0, maxBurnTime: 0, cookProgress: 0 }; } toggleInventory(false, key); return; }
                if (activeItem && activeItem.id === 64) { if (world[key] === 63) { delete world[key]; activeItem.count--; if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; addItemToInventory(65, 1); broadcastWorldChange(); return; } else if (world[key] === 6) { delete world[key]; activeItem.count--; if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; addItemToInventory(66, 1); broadcastWorldChange(); return; } }
                if (activeItem && (!world[key] || BLOCK_TYPES[world[key]]?.fluid) && !BLOCK_TYPES[activeItem.id].item) { if (!checkOverlap(player, { x: wx * TILE_SIZE, y: wy * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE })) { world[key] = activeItem.id; if (player.gameMode !== 'creative') { activeItem.count--; if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; } broadcastWorldChange(); } }
            }
        }

        function updateMobs() {
            if (isLanClient) return;
            const currentMobs = mobs[currentDimension], world = worlds[currentDimension], isNight = gameTime > 13000 && gameTime < 23000, spawnChance = currentDimension === 'overworld' ? (isNight ? 0.08 : 0.02) : 0.05;
            if (currentMobs.length < 15 && Math.random() < spawnChance) { const spawnX = player.x + (Math.random() > 0.5 ? 1 : -1) * (width/2 + 200 + Math.random() * 400), sx = Math.floor(spawnX / TILE_SIZE); if (sx >= 0 && sx < WORLD_WIDTH) { let sy = 0; while(!world[`${sx},${sy}`] && sy < WORLD_HEIGHT) sy++; if (sy < WORLD_HEIGHT) { let types = []; if (currentDimension === 'overworld') types = isNight ? ['zombie_pig', 'creeper_clock'] : ['chicken']; else types = ['zombie_pig', 'creeper_clock']; if (types.length > 0) mobs[currentDimension].push({ ...MOB_TYPES[types[Math.floor(Math.random()*types.length)]], type: types[Math.floor(Math.random()*types.length)], x: spawnX, y: (sy-2)*TILE_SIZE, vx: 0, vy: 0, facing: 1, animTimer: 0, grounded: false, fuse: 0 }); } } }
            for(let i = currentMobs.length - 1; i >= 0; i--) {
                const m = currentMobs[i], dx = player.x - m.x, dy = player.y - m.y, dist = Math.hypot(dx, dy); if (dist > 2000) { currentMobs.splice(i, 1); continue; }
                if (m.behavior === 'chase' || m.behavior === 'explode') { if (dist < 400) { m.vx += (dx > 0 ? 1 : -1) * 0.5; m.facing = dx > 0 ? 1 : -1; if (dist < 100 && Math.random() < 0.1 && m.grounded) m.vy = -12; } else m.vx *= 0.8; }
                if (m.behavior === 'explode' && dist < 60) { m.fuse++; if (m.fuse >= 40) { if(Math.hypot(player.x-m.x, player.y-m.y) < 120) takeDamage(3); createParticles(m.x, m.y, '#ff4500', 30); currentMobs.splice(i, 1); continue; } } else m.fuse = Math.max(0, m.fuse - 1);
                if (m.damage > 0 && dist < 40 && player.invuln <= 0) takeDamage(m.damage);
                m.vx *= 0.8; m.vy += GRAVITY; m.x += m.vx; resolveCollision('x', m); m.y += m.vy; m.grounded = false; resolveCollision('y', m); m.animTimer += Math.abs(m.vx) * 0.1;
            }
        }

        function resolveCollision(axis, e) {
            const world = worlds[currentDimension], x1 = Math.floor(e.x / TILE_SIZE), x2 = Math.floor((e.x + (e.w||34) - 1) / TILE_SIZE), y1 = Math.floor(e.y / TILE_SIZE), y2 = Math.floor((e.y + (e.h||28) - 1) / TILE_SIZE);
            for (let x = x1; x <= x2; x++) { for (let y = y1; y <= y2; y++) { const type = world[`${x},${y}`]; if (type && !BLOCK_TYPES[type].teleport && !BLOCK_TYPES[type].fluid && !BLOCK_TYPES[type].ladder) { if (axis === 'x') { if (e.vx > 0) e.x = x * TILE_SIZE - (e.w||34); else if (e.vx < 0) e.x = (x + 1) * TILE_SIZE; e.vx = 0; } else { if (e.vy > 0) { e.y = y * TILE_SIZE - (e.h||28); e.grounded = true; } else if (e.vy < 0) e.y = (y + 1) * TILE_SIZE; e.vy = 0; } } } }
        }

        function loop(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp; const deltaTime = timestamp - lastTimestamp; lastTimestamp = timestamp; tickAccumulator += deltaTime;
            while (tickAccumulator >= TICK_TIME) { update(); tickAccumulator -= TICK_TIME; }
            draw(); requestAnimationFrame(loop);
        }

        let fluidTimer = 0;
        function update() {
            if (!gameStarted || player.dead || isPaused) return;
            if (player.invuln > 0) player.invuln--;
            if (!isLanClient) gameTime = (gameTime + 2) % DAY_LENGTH;
            const hours = Math.floor((gameTime / DAY_LENGTH) * 24), minutes = Math.floor(((gameTime % (DAY_LENGTH / 24)) / (DAY_LENGTH / 24)) * 60);
            timeIndicatorEl.innerText = `${(hours % 12 || 12).toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} ${hours >= 12 ? 'PM' : 'AM'}`;
            updateMobs(); syncMultiplayerData();
            const world = worlds[currentDimension];
            
            // SMELTING LOGIC - Host Only
            if (isLanHost || !lanSessionCode) {
                const furnaces = tileEntities[currentDimension];
                for (let pos in furnaces) {
                    const f = furnaces[pos]; if (!world[pos] || !BLOCK_TYPES[world[pos]].furnace) { delete furnaces[pos]; continue; }
                    const recipe = SMELTING_RECIPES[f.input?.id], canSmelt = recipe && (!f.output || (f.output.id === recipe.result && f.output.count < 64));
                    if (f.burnTime > 0) { f.burnTime--; if (canSmelt) { f.cookProgress++; if (f.cookProgress >= recipe.time) { f.cookProgress = 0; f.input.count--; if (f.input.count <= 0) f.input = null; if (!f.output) f.output = { id: recipe.result, count: 1 }; else f.output.count++; } } else f.cookProgress = 0; }
                    if (f.burnTime <= 0 && canSmelt && f.fuel) { const fuelVal = FUEL_VALUES[f.fuel.id]; if (fuelVal) { f.burnTime = fuelVal; f.maxBurnTime = fuelVal; f.fuel.count--; if (f.fuel.count <= 0) f.fuel = null; } }
                    if (f.burnTime <= 0 && !canSmelt) f.cookProgress = 0;
                }
            }
            if (inventoryOpen) renderInventory();

            if (inventoryOpen) return;
            fluidTimer++; if (fluidTimer >= 5) { fluidTimer = 0; const world = worlds[currentDimension], fluidKeys = Object.keys(world).filter(k => BLOCK_TYPES[world[k]]?.fluid); for (const k of fluidKeys) { const [wx, wy] = k.split(',').map(Number), selfType = world[k], targetBelow = world[`${wx},${wy+1}`]; if (wy+1 < WORLD_HEIGHT && !targetBelow) { delete world[k]; world[`${wx},${wy+1}`] = selfType; } } }
            particles = particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.6; p.life--; return p.life > 0; });
            const px = Math.floor((player.x + player.w/2) / TILE_SIZE), py = Math.floor((player.y + player.h/2) / TILE_SIZE), standingOn = world[`${px},${py}`];
            if (standingOn === 60 || standingOn === 90) { teleportTimer++; portalOverlay.style.opacity = teleportTimer / 20; if (teleportTimer >= 20) { currentDimension = (standingOn === 60) ? (currentDimension === 'overworld' ? 'nether' : 'overworld') : (currentDimension === 'overworld' ? 'the_end' : 'overworld'); teleportTimer = 0; portalOverlay.style.opacity = 0; player.x = (WORLD_WIDTH/2)*TILE_SIZE; let startY = 0; while(!worlds[currentDimension][`${Math.floor(player.x/TILE_SIZE)},${startY}`] && startY < WORLD_HEIGHT) startY++; player.y = (startY - 2) * TILE_SIZE; updateHUD(); saveGame(); } } else { teleportTimer = 0; portalOverlay.style.opacity = 0; }
            if (mouse.down) { const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE), wy = Math.floor((mouse.y + camera.y) / TILE_SIZE), targetBlock = world[`${wx},${wy}`]; if (targetBlock && !BLOCK_TYPES[targetBlock].fluid) { if (miningTarget?.key === `${wx},${wy}`) { miningProgress += getMiningSpeed(); if (miningProgress >= BLOCK_TYPES[targetBlock].hardness) { if (player.gameMode !== 'creative') addItemToInventory(BLOCK_TYPES[targetBlock].drop || parseInt(targetBlock), 1); delete world[`${wx},${wy}`]; miningTarget = null; broadcastWorldChange(); } } else miningTarget = { wx, wy, key: `${wx},${wy}` }; } }
            let curSpeed = keys['shift'] ? SPRINT_SPEED : SPEED; if (player.isFlying) curSpeed *= 1.5; if (BLOCK_TYPES[world[`${px},${py}`]]?.fluid) { curSpeed *= 0.4; if (keys['w'] || keys[' ']) player.vy = -6; else player.vy *= 0.8; }
            if (keys['a'] || keys['arrowleft']) { player.vx -= curSpeed; player.facing = -1; player.animTimer += 0.8; } if (keys['d'] || keys['arrowright']) { player.vx += curSpeed; player.facing = 1; player.animTimer += 0.8; } player.vx *= FRICTION; player.x += player.vx; resolveCollision('x', player);
            if (BLOCK_TYPES[world[`${px},${py}`]]?.ladder) { player.vy = (keys['w'] || keys[' ']) ? -7 : 4; player.grounded = true; } else if (!player.isFlying) { if ((keys['w'] || keys[' ']) && player.grounded) { player.vy = JUMP; player.grounded = false; player.squash = 1.3; } player.vy += GRAVITY; } else if (player.isFlying) player.vy = (keys['w'] || keys[' ']) ? -20 : (keys['s'] ? 20 : player.vy*0.5);
            player.y += player.vy; player.squash += (1 - player.squash) * 0.45; player.grounded = false; if (player.y + player.h > WORLD_HEIGHT * TILE_SIZE) takeDamage(10); resolveCollision('y', player);
            camera.x += (player.x - width/2 - camera.x) * 0.35; camera.y += (player.y - height/2 - camera.y) * 0.35;
        }

        function drawEntity(e) {
            ctx.save(); ctx.translate(e.x + (e.w || 34)/2, e.y + (e.h || 28)); const squash = 1 + Math.sin(e.animTimer || 0) * 0.1; ctx.scale(e.facing || 1, squash); ctx.translate(-(e.w || 34)/2, -(e.h || 28));
            if (e.type === 'zombie_pig') { ctx.fillStyle = '#556b2f'; ctx.fillRect(0, 4, e.w, e.h - 10); ctx.strokeStyle = '#3e4d22'; ctx.lineWidth = 2; ctx.strokeRect(0, 4, e.w, e.h - 10); ctx.fillRect(4, e.h - 8, 8, 8); ctx.fillRect(e.w - 12, e.h - 8, 8, 8); ctx.fillStyle = '#3e4d22'; ctx.fillRect(e.w - 6, 12, 10, 10); ctx.fillStyle = '#f00'; ctx.fillRect(e.w - 10, 8, 4, 4); } 
            else if (e.type === 'creeper_clock') { const clockFlash = e.fuse > 0 && Math.floor(Date.now()/100) % 2 === 0; ctx.fillStyle = clockFlash ? '#fff' : '#fdd835'; ctx.fillRect(4, 0, e.w - 8, e.h - 10); ctx.fillRect(0, e.h - 10, 10, 10); ctx.fillRect(e.w - 10, e.h - 10, 10, 10); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(e.w/2, 12, 8, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(e.w/2, 12); const time = Date.now() / (e.fuse > 0 ? 50 : 300); ctx.lineTo(e.w/2 + Math.cos(time)*6, 12 + Math.sin(time)*6); ctx.stroke(); } 
            else if (e.type === 'chicken') { ctx.fillStyle = '#fff'; ctx.fillRect(4, 4, e.w-8, e.h-8); ctx.fillStyle = '#f90'; ctx.fillRect(e.w-6, 8, 6, 4); ctx.fillStyle = '#f00'; ctx.fillRect(6, 0, 4, 4); ctx.fillStyle = '#eee'; const wingW = 4 + Math.sin(e.animTimer)*2; ctx.fillRect(-wingW, 8, wingW, 8); }
            else { ctx.fillStyle = '#ffb6c1'; ctx.fillRect(0, 4, 34, 18); ctx.strokeStyle = '#ff69b4'; ctx.lineWidth = 2; ctx.strokeRect(0, 4, 34, 18); ctx.fillRect(4, 20, 8, 8); ctx.fillRect(22, 20, 8, 8); ctx.fillStyle = '#ff69b4'; ctx.fillRect(28, 12, 10, 10); ctx.fillStyle = '#000'; ctx.fillRect(24, 8, 4, 4); ctx.fillStyle = '#fff'; ctx.font = '5px "Press Start 2P"'; ctx.fillText(e.id?.substr(0,4) || "PIG", 0, -5); }
            ctx.restore();
        }

        function drawBlock(x, y, type) {
            const b = BLOCK_TYPES[type]; if(!b) return; const size = TILE_SIZE, tx = x * size, ty = y * size, world = worlds[currentDimension];
            ctx.fillStyle = b.color; if (b.animated) { const time = Date.now()/300; if (type === 60) ctx.fillStyle = `hsl(${280 + Math.sin(time + x + y) * 30}, 70%, 30%)`; else if (type === 90) ctx.fillStyle = `rgb(${10 + Math.sin(time)*5}, 0, ${30 + Math.cos(time)*10})`; else if (type === 52) ctx.fillStyle = `hsl(50, 90%, ${70 + Math.sin(time) * 10}%)`; }
            if (b.texture === 'glass') { ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fillRect(tx, ty, size, size); ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 1; ctx.strokeRect(tx, ty, size, size); }
            else if (b.fluid) { if (world[`${x},${y-1}`] === type) ctx.fillRect(tx, ty, size, size); else { ctx.fillRect(tx, ty + 6, size, size - 6); ctx.fillStyle = (type === 63 ? '#166fb8' : '#ff7043'); ctx.fillRect(tx, ty + 6 + Math.sin(Date.now()/300 + x) * 2, size, 3); } } 
            else ctx.fillRect(tx, ty, size, size);
            if (type === 67) { const f = tileEntities[currentDimension][`${x},${y}`]; if (f && f.burnTime > 0) { ctx.fillStyle = '#ff5722'; ctx.fillRect(tx + size*0.15, ty + size*0.15, size*0.7, size*0.2); } }
            if (type === 11) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(tx + size/2, ty + size/2, size/2.5, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(tx + size/2, ty + size/2); ctx.lineTo(tx + size/2 + Math.cos((gameTime/DAY_LENGTH)*Math.PI*2)*10, ty + size/2 + Math.sin((gameTime/DAY_LENGTH)*Math.PI*2)*10); ctx.stroke(); }
            if (!b.fluid && b.texture !== 'glass') { ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 2; ctx.strokeRect(tx+1, ty+1, size-2, size-2); ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.strokeRect(tx, ty, size, size); }
        }

        function getSkyColor() { if (currentDimension === 'nether') return '#1a0505'; if (currentDimension === 'the_end') return '#0b001a'; const t = gameTime/DAY_LENGTH; if (t < 0.2) return '#ff7043'; if (t < 0.5) return '#4a90e2'; if (t < 0.6) return '#fb8c00'; if (t < 0.9) return '#0a0a20'; return '#2a1a4a'; }
        function draw() {
            ctx.fillStyle = getSkyColor(); ctx.fillRect(0, 0, width, height);
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            const world = worlds[currentDimension], v1 = Math.max(0, Math.floor(camera.x/TILE_SIZE)-1), v2 = Math.min(WORLD_WIDTH-1, Math.ceil((camera.x+width)/TILE_SIZE)+1), v3 = Math.max(0, Math.floor(camera.y/TILE_SIZE)-1), v4 = Math.min(WORLD_HEIGHT-1, Math.ceil((camera.y+height)/TILE_SIZE)+1);
            for (let x = v1; x <= v2; x++) for (let y = v3; y <= v4; y++) if (world[`${x},${y}`]) drawBlock(x, y, world[`${x},${y}`]);
            mobs[currentDimension].forEach(drawEntity);
            Object.values(otherPlayers).forEach(p => { if (p.dim === currentDimension) drawEntity(p); });
            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 50; ctx.fillRect(p.x, p.y, 6, 6); }); ctx.globalAlpha = 1;
            if (!player.dead && player.invuln % 6 < 3) { ctx.save(); ctx.translate(player.x + player.w/2, player.y + player.h); ctx.scale(player.facing, player.squash); ctx.translate(-player.w/2, -player.h); ctx.fillStyle = '#ffb6c1'; ctx.fillRect(0, 4, player.w, player.h-10); ctx.strokeStyle = '#ff69b4'; ctx.lineWidth = 2; ctx.strokeRect(0, 4, player.w, player.h-10); ctx.fillRect(4, player.h-8, 8, 8); ctx.fillRect(player.w-12, player.h-8, 8, 8); ctx.fillStyle = '#ff69b4'; ctx.fillRect(player.w-6, 12, 10, 10); ctx.fillStyle = '#000'; ctx.fillRect(player.w-10, 8, 4, 4); ctx.restore(); }
            ctx.restore();
            if (currentDimension === 'overworld') { const t = gameTime/DAY_LENGTH; if (t > 0.6 || t < 0.2) { ctx.fillStyle = `rgba(0, 0, 15, ${Math.min(0.6, (gameTime > 13000 ? (gameTime-13000)/1000 : (24000-gameTime)/1000))})`; ctx.fillRect(0, 0, width, height); } }
        }
        init();
    </script>
</body>
</html>
