
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Moinkcraft: The Nether Update</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press+Start+2P', cursive;
            background: #0d0d1a;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #4a90e2;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            image-rendering: pixelated;
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #title-screen {
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            text-align: center;
            padding: 20px;
            overflow: hidden;
        }

        .floating-numbers {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }

        .time-particle {
            position: absolute;
            font-size: 20px;
            color: rgba(212, 175, 55, 0.2);
            animation: driftUp 10s linear infinite;
        }

        @keyframes driftUp {
            0% { transform: translateY(110vh) rotate(0deg); opacity: 0; }
            20% { opacity: 0.5; }
            80% { opacity: 0.5; }
            100% { transform: translateY(-10vh) rotate(360deg); opacity: 0; }
        }

        .hero-scene {
            position: relative;
            width: 200px;
            height: 250px;
            margin-bottom: 40px;
            z-index: 10;
        }

        .title-clock {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            background: #f1c40f;
            border: 8px solid #b8860b;
            border-radius: 50%;
            box-shadow: 0 10px 0 #8b6b00, 0 20px 30px rgba(0,0,0,0.5);
        }

        .title-clock::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 40px;
            background: #333;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: translate(-50%, -100%) rotate(0deg); }
            to { transform: translate(-50%, -100%) rotate(360deg); }
        }

        .title-pig {
            position: absolute;
            width: 70px;
            height: 55px;
            background: #ffb6c1;
            bottom: 140px;
            left: 50%;
            margin-left: -35px;
            border-bottom: 6px solid #ff69b4;
            border-radius: 4px;
            animation: pigJump 1.2s cubic-bezier(0.45, 0, 0.55, 1) infinite;
        }

        /* Detailed Pig Parts */
        .title-pig::before { content: ''; position: absolute; right: -8px; top: 25px; width: 14px; height: 18px; background: #ff69b4; border-right: 3px solid #c71585; border-radius: 2px; }
        .title-pig::after { content: ''; position: absolute; right: 14px; top: 15px; width: 8px; height: 8px; background: #000; box-shadow: -25px 0 0 #000; border-radius: 1px; }

        @keyframes pigJump {
            0%, 100% { transform: translateY(0) scaleY(1); }
            50% { transform: translateY(-120px) scaleY(1.1); }
            95% { transform: translateY(8px) scaleY(0.75); }
        }

        .game-title {
            font-size: 36px;
            color: #ffb6c1;
            text-shadow: 4px 4px 0px #c71585, 8px 8px 0px rgba(0,0,0,0.4);
            margin-bottom: 30px;
            letter-spacing: -2px;
            z-index: 10;
            position: relative;
        }

        .game-title span { color: #f1c40f; text-shadow: 4px 4px 0px #b8860b; }

        .instructions {
            margin-top: 30px;
            font-size: 8px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            line-height: 2;
            text-align: center;
            border: 4px solid #444;
            border-radius: 8px;
            max-width: 360px;
            color: #ddd;
            z-index: 10;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .hud-anchor {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: none;
            z-index: 50;
        }

        .hotbar-hud { display: flex; background: rgba(0, 0, 0, 0.6); padding: 4px; border: 4px solid #1a1a1a; pointer-events: auto; }
        .hud-slot { width: 52px; height: 52px; border: 4px solid transparent; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.05); position: relative; }
        .hud-slot.active { border-color: #fff; background: rgba(255, 255, 255, 0.25); box-shadow: inset 0 0 10px rgba(255,255,255,0.5); }

        #inventory-screen { position: absolute; inset: 0; background: rgba(0, 0, 0, 0.7); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
        .mc-container { background: #c6c6c6; border: 6px solid; border-color: #eee #444 #444 #eee; padding: 20px; box-shadow: 8px 8px 0 rgba(0,0,0,0.6); display: flex; flex-direction: column; gap: 15px; position: relative; }
        .mc-label { color: #222; font-size: 9px; margin-bottom: 6px; font-weight: bold; }
        .mc-slot { width: 48px; height: 48px; background: #8b8b8b; border: 4px solid; border-color: #373737 #fefefe #fefefe #373737; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; }
        .mc-slot:hover { background: #aaa; box-shadow: inset 0 0 0 2px rgba(255,255,255,0.3); }
        .mc-slot.output { width: 56px; height: 56px; border-width: 5px; }
        .mc-grid { display: grid; gap: 4px; }
        .top-section { display: flex; gap: 40px; align-items: flex-start; }
        .crafting-section { display: flex; align-items: center; gap: 20px; }
        .crafting-grid-2x2 { display: grid; grid-template-columns: repeat(2, 48px); gap: 4px; }
        .crafting-grid-3x3 { display: grid; grid-template-columns: repeat(3, 48px); gap: 4px; }
        .arrow-right { width: 34px; height: 24px; background: #444; clip-path: polygon(0% 20%, 60% 20%, 60% 0%, 100% 50%, 60% 100%, 60% 80%, 0% 80%); }
        .block-icon { width: 34px; height: 34px; pointer-events: none; position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center; box-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 11px; color: #fff; text-shadow: 2px 2px #000; font-weight: bold; pointer-events: none; z-index: 10; }
        .tool-stick { position: absolute; width: 4px; height: 24px; background: #5c3b1e; transform: rotate(-45deg); box-shadow: 1px 1px 1px rgba(0,0,0,0.3); }
        #held-item-cursor { position: fixed; pointer-events: none; z-index: 1000; display: none; filter: drop-shadow(4px 4px 2px rgba(0,0,0,0.5)); }
        .status-ui { position: absolute; top: 25px; left: 25px; display: flex; flex-direction: column; gap: 12px; }
        .hearts { display: flex; gap: 6px; pointer-events: none; }
        .heart { width: 22px; height: 22px; background: #ff4d4d; border: 3px solid #7a0000; box-shadow: 3px 3px 0 rgba(0,0,0,0.3); border-radius: 4px; }
        .heart.empty { background: #222; border-color: #000; box-shadow: none; }
        #death-screen { position: absolute; inset: 0; background: rgba(30,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 101; }
        .btn { margin-top: 15px; padding: 15px 30px; background: #5b8a3e; border: 6px solid; border-color: #92c47c #2d451f #2d451f #92c47c; color: #fff; cursor: pointer; font-size: 12px; pointer-events: auto; text-align: center; box-shadow: 6px 6px 0 rgba(0,0,0,0.4); z-index: 10; transition: transform 0.1s; }
        .btn:hover { background: #6da34a; transform: scale(1.05); }
        .btn:active { transform: translateY(3px); box-shadow: 3px 3px 0 rgba(0,0,0,0.4); }
        #portal-overlay {
            position: absolute;
            inset: 0;
            background: #4a148c;
            opacity: 0;
            z-index: 300;
            pointer-events: none;
            transition: opacity 1s;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="portal-overlay"></div>
        <div id="held-item-cursor"></div>
        <div id="title-screen">
            <div class="floating-numbers" id="floating-numbers"></div>
            <div class="hero-scene">
                <div class="title-pig"></div>
                <div class="title-clock"></div>
            </div>
            <h1 class="game-title">MOINK <span>O'CLOCK</span></h1>
            <div class="btn" onclick="startGame()" style="font-size: 16px;">START JOURNEY</div>
            <div class="instructions">
                WASD/Arrows: Move & Jump<br>
                SHIFT: Sprint | E: Inventory<br>
                L-CLICK: Mine | R-CLICK: Use/Place<br>
                Build a <span>Portal</span> and Jump on the <span>Clock</span>!
            </div>
            <div style="margin-top: 20px; font-size: 8px; color: #777;">PROTOTYPE v2.5 - HD TEXTURES</div>
        </div>
        <div class="ui-overlay">
            <div class="status-ui">
                <div id="coords" style="font-size: 10px; color: #fff; text-shadow: 2px 2px #000;">X: 0 Y: 0</div>
                <div id="dim-indicator" style="font-size: 10px; color: #ffb6c1; text-shadow: 2px 2px #000;">Overworld</div>
            </div>
            <div class="hud-anchor">
                <div class="hearts" id="hearts-container"></div>
                <div class="hotbar-hud" id="hotbar-hud"></div>
            </div>
        </div>
        <div id="inventory-screen">
            <div class="mc-container" id="mc-inventory">
                <div class="top-section">
                    <div id="pig-preview" style="width: 100px; height: 120px; background: #8b8b8b; border: 4px solid #373737; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;">
                        <span style="font-size: 8px; color: #444; font-weight: bold;">PIGGY</span>
                        <!-- Mini Pig Preview -->
                        <div style="position: absolute; width: 40px; height: 30px; background: #ffb6c1; border: 2px solid #ff69b4; border-radius: 2px;">
                           <div style="position: absolute; right: 2px; top: 4px; width: 4px; height: 4px; background: #000;"></div>
                        </div>
                    </div>
                    <div>
                        <div class="mc-label" id="crafting-label">Crafting</div>
                        <div class="crafting-section">
                            <div class="crafting-grid-2x2" id="crafting-grid-2x2">
                                <div class="mc-slot" data-type="craft2" data-idx="0"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="1"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="2"></div>
                                <div class="mc-slot" data-type="craft2" data-idx="3"></div>
                            </div>
                            <div class="crafting-grid-3x3" id="crafting-grid-3x3" style="display: none;">
                                <div class="mc-slot" data-type="craft3" data-idx="0"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="1"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="2"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="3"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="4"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="5"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="6"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="7"></div>
                                <div class="mc-slot" data-type="craft3" data-idx="8"></div>
                            </div>
                            <div class="arrow-right"></div>
                            <div class="mc-slot output" id="crafting-output"></div>
                        </div>
                    </div>
                </div>
                <div>
                    <div class="mc-label">Inventory</div>
                    <div class="mc-grid" style="grid-template-columns: repeat(9, 48px);" id="main-inventory-grid"></div>
                </div>
                <div style="margin-top: 8px;">
                    <div class="mc-grid" style="grid-template-columns: repeat(9, 48px);" id="hotbar-inventory-grid"></div>
                </div>
            </div>
        </div>
        <div id="death-screen">
            <h1 style="color: #ff4d4d; font-size: 24px; margin-bottom: 25px; text-shadow: 4px 4px #000;">YOU FAILED THE OINK</h1>
            <div class="btn" onclick="respawn()">START NEW CYCLE</div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 40;
        const GRAVITY = 0.45;
        const FRICTION = 0.8;
        const SPEED = 0.5;
        const SPRINT_SPEED = 0.9;
        const JUMP = -10;
        const MAX_HEALTH = 10;
        const INVULN_TIME = 45;
        const WORLD_WIDTH = 100;
        const WORLD_HEIGHT = 100;

        const BLOCK_TYPES = {
            1: { name: 'Grass', color: '#5b8a3e', stroke: '#3e5b2e', hardness: 10, tool: 'shovel', topColor: '#76b052' },
            2: { name: 'Dirt', color: '#7a5a3a', stroke: '#4d3a24', hardness: 12, tool: 'shovel' },
            3: { name: 'Stone', color: '#828282', stroke: '#555555', hardness: 50, tool: 'pickaxe', texture: 'stone' },
            4: { name: 'Wood', color: '#6d4c41', stroke: '#3e2723', hardness: 30, tool: 'axe' },
            5: { name: 'Leaves', color: '#2e7d32', stroke: '#1b5e20', hardness: 5 },
            6: { name: 'Lava', color: '#ff5722', stroke: '#bf360c', hazard: true, hardness: 1000, animated: true },
            7: { name: 'Cobble', color: '#616161', stroke: '#424242', hardness: 45, tool: 'pickaxe', texture: 'cobble' },
            8: { name: 'Sand', color: '#ffecb3', stroke: '#ffe082', hardness: 10, tool: 'shovel' },
            10: { name: 'Planks', color: '#d2b48c', stroke: '#8b4513', hardness: 25, tool: 'axe' },
            11: { name: 'Clock', color: '#fdd835', stroke: '#f9a825', special: true, hardness: 80, tool: 'pickaxe' },
            12: { name: 'Crafting Table', color: '#795548', stroke: '#3e2723', hardness: 40, table: true, tool: 'axe' },
            13: { name: 'Coal Ore', color: '#828282', stroke: '#555555', hardness: 55, ore: '#212121', tool: 'pickaxe', drop: 30 },
            14: { name: 'Iron Ore', color: '#828282', stroke: '#555555', hardness: 75, ore: '#d7ccc8', tool: 'pickaxe', drop: 31 },
            15: { name: 'Stick', color: '#5d4037', stroke: '#3e2723', hardness: 10, item: true },
            16: { name: 'Wood Pickaxe', color: '#6d4c41', toolType: 'pickaxe', tier: 1, item: true },
            17: { name: 'Wood Shovel', color: '#6d4c41', toolType: 'shovel', tier: 1, item: true },
            18: { name: 'Wood Axe', color: '#6d4c41', toolType: 'axe', tier: 1, item: true },
            19: { name: 'Stone Pickaxe', color: '#616161', toolType: 'pickaxe', tier: 2, item: true },
            20: { name: 'Stone Shovel', color: '#616161', toolType: 'shovel', tier: 2, item: true },
            21: { name: 'Stone Axe', color: '#616161', toolType: 'axe', tier: 2, item: true },
            22: { name: 'Iron Pickaxe', color: '#e0e0e0', toolType: 'pickaxe', tier: 3, item: true },
            23: { name: 'Iron Shovel', color: '#e0e0e0', toolType: 'shovel', tier: 3, item: true },
            24: { name: 'Iron Axe', color: '#e0e0e0', toolType: 'axe', tier: 3, item: true },
            25: { name: 'Gold Ore', color: '#828282', stroke: '#555555', hardness: 80, ore: '#ffeb3b', tool: 'pickaxe', drop: 32 },
            26: { name: 'Diamond Ore', color: '#828282', stroke: '#555555', hardness: 150, ore: '#80deea', tool: 'pickaxe', drop: 33 },
            28: { name: 'Obsidian', color: '#212121', stroke: '#1a1a1a', hardness: 600, tool: 'pickaxe', texture: 'obsidian' },
            29: { name: 'Bedrock', color: '#1a1a1a', stroke: '#000000', hardness: 999999 },
            30: { name: 'Coal', color: '#212121', item: true },
            31: { name: 'Iron Ingot', color: '#f5f5f5', item: true },
            32: { name: 'Gold Ingot', color: '#fff176', item: true },
            33: { name: 'Diamond', color: '#00e5ff', item: true },
            51: { name: 'Netherrack', color: '#b71c1c', stroke: '#7f0000', hardness: 15, tool: 'pickaxe', texture: 'netherrack' },
            52: { name: 'Glowstone', color: '#fff59d', stroke: '#fbc02d', hardness: 10, animated: true },
            57: { name: 'Gravel', color: '#bdbdbd', stroke: '#9e9e9e', hardness: 10, tool: 'shovel', dropChance: 0.1, dropId: 58 },
            58: { name: 'Flint', color: '#424242', item: true },
            59: { name: 'Flint and Steel', color: '#e0e0e0', item: true, action: 'ignite' },
            60: { name: 'Nether Portal', color: '#6a1b9a', stroke: '#4a148c', hardness: 999, animated: true, teleport: true },
            61: { name: 'Soul Sand', color: '#5d4037', stroke: '#3e2723', hardness: 15, tool: 'shovel' },
            62: { name: 'Magma', color: '#bf360c', stroke: '#ff5722', hazard: true, hardness: 40, tool: 'pickaxe', animated: true }
        };

        const RECIPES = [
            { pattern: [[4]], result: 10, amount: 4 },
            { pattern: [[10], [10]], result: 15, amount: 4 },
            { pattern: [[10, 10], [10, 10]], result: 12, amount: 1 },
            { pattern: [[7, 7, 7], [null, 15, null], [null, 15, null]], result: 19, amount: 1 },
            { pattern: [[10, 10, 10], [null, 15, null], [null, 15, null]], result: 16, amount: 1 },
            { pattern: [[31, 31, 31], [null, 15, null], [null, 15, null]], result: 22, amount: 1 },
            { pattern: [[10], [15], [15]], result: 17, amount: 1 },
            { pattern: [[7], [15], [15]], result: 20, amount: 1 },
            { pattern: [[31], [15], [15]], result: 23, amount: 1 },
            { pattern: [[10, 10], [10, 15], [null, 15]], result: 18, amount: 1 },
            { pattern: [[7, 7], [7, 15], [null, 15]], result: 21, amount: 1 },
            { pattern: [[31, 31], [31, 15], [null, 15]], result: 24, amount: 1 },
            { pattern: [[null, 32, null], [32, 15, 32], [null, 32, null]], result: 11, amount: 1 },
            { pattern: [[30], [15]], result: 1, amount: 1 }, 
            { pattern: [[58, 31]], result: 59, amount: 1 } 
        ];

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const heartsContainer = document.getElementById('hearts-container');
        const portalOverlay = document.getElementById('portal-overlay');
        
        let width, height;
        let camera = { x: 0, y: 0 };
        let currentDimension = 'overworld';
        let worlds = { overworld: {}, nether: {} };
        let teleportTimer = 0;
        
        // Detailed Player State
        let player = { 
            x: (WORLD_WIDTH / 2) * TILE_SIZE, 
            y: 0, 
            vx: 0, 
            vy: 0, 
            w: 34, 
            h: 28, 
            grounded: false, 
            health: MAX_HEALTH, 
            invuln: 0, 
            dead: false, 
            facing: 1,
            animTimer: 0,
            squash: 1
        };
        
        let mainInventory = new Array(27).fill(null);
        let hotbarInventory = new Array(9).fill(null);
        let craftingGrid2x2 = new Array(4).fill(null);
        let craftingGrid3x3 = new Array(9).fill(null);
        let craftingOutput = null;
        let activeRecipeMatch = null;
        let heldItem = null;

        let isUsingTable = false;
        let miningTarget = null;
        let miningProgress = 0;
        let activeHotbarIndex = 0; 
        let inventoryOpen = false;
        let gameStarted = false;
        let keys = {};
        let mouse = { x: 0, y: 0, down: false, rightDown: false };
        let particles = [];

        function init() {
            resize();
            generateOverworld();
            generateNether();
            setupInventoryUI();
            updateHUD();
            updateHeartsUI();
            setupTitleParticles();
            
            const startX = Math.floor(WORLD_WIDTH / 2);
            let startY = 0;
            const world = worlds[currentDimension];
            while(!world[`${startX},${startY}`] && startY < WORLD_HEIGHT) startY++;
            player.x = startX * TILE_SIZE;
            player.y = (startY - 2) * TILE_SIZE;

            window.addEventListener('resize', resize);
            window.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if (!gameStarted) return;
                if (e.key === 'e') toggleInventory();
                if (!inventoryOpen && e.key >= '1' && e.key <= '9') { activeHotbarIndex = parseInt(e.key) - 1; updateHUD(); }
            });
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            window.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
                if (gameStarted) updateHeldItemCursor();
            });
            window.addEventListener('mousedown', e => {
                if (!gameStarted) return;
                if (e.button === 0) mouse.down = true;
                if (e.button === 2) { mouse.rightDown = true; if (!inventoryOpen) handleWorldInteraction(); }
            });
            window.addEventListener('mouseup', e => { if (e.button === 0) mouse.down = false; if (e.button === 2) mouse.rightDown = false; });
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            requestAnimationFrame(loop);
        }

        function createParticles(x, y, color, count = 5) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: -Math.random() * 5,
                    color,
                    life: 30 + Math.random() * 20
                });
            }
        }

        function setupTitleParticles() {
            const container = document.getElementById('floating-numbers');
            for(let i=0; i<15; i++) {
                const p = document.createElement('div');
                p.className = 'time-particle';
                p.innerText = Math.floor(Math.random() * 12) + 1;
                p.style.left = Math.random() * 100 + 'vw';
                p.style.animationDelay = (Math.random() * 10) + 's';
                p.style.fontSize = (Math.random() * 20 + 20) + 'px';
                container.appendChild(p);
            }
        }

        function startGame() { gameStarted = true; document.getElementById('title-screen').style.display = 'none'; }
        function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }

        function toggleInventory(useTable = false) {
            inventoryOpen = !inventoryOpen;
            isUsingTable = useTable;
            const screen = document.getElementById('inventory-screen');
            screen.style.display = inventoryOpen ? 'flex' : 'none';
            document.getElementById('crafting-grid-2x2').style.display = isUsingTable ? 'none' : 'grid';
            document.getElementById('crafting-grid-3x3').style.display = isUsingTable ? 'grid' : 'none';
            document.getElementById('pig-preview').style.display = isUsingTable ? 'none' : 'flex';
            document.getElementById('crafting-label').innerText = isUsingTable ? 'Crafting Table' : 'Crafting';
            if (!inventoryOpen) {
                const returnItems = (grid) => { grid.forEach((item, i) => { if (item) addItemToInventory(item.id, item.count); grid[i] = null; }); };
                returnItems(craftingGrid2x2); returnItems(craftingGrid3x3);
                if (heldItem) { addItemToInventory(heldItem.id, heldItem.count); heldItem = null; }
                updateHeldItemCursor();
            }
            renderInventory();
        }

        function setupInventoryUI() {
            const setupSlot = (slot) => {
                slot.addEventListener('mousedown', (e) => {
                    const type = slot.dataset.type;
                    const idx = parseInt(slot.dataset.idx);
                    handleSlotClick(type, idx, e.button);
                    e.preventDefault();
                });
                slot.addEventListener('contextmenu', (e) => e.preventDefault());
            };
            const mainGrid = document.getElementById('main-inventory-grid');
            mainGrid.innerHTML = '';
            for (let i = 0; i < 27; i++) {
                const slot = document.createElement('div');
                slot.className = 'mc-slot';
                slot.dataset.type = 'main'; slot.dataset.idx = i;
                setupSlot(slot);
                mainGrid.appendChild(slot);
            }
            const hbGrid = document.getElementById('hotbar-inventory-grid');
            hbGrid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'mc-slot';
                slot.dataset.type = 'hotbar'; slot.dataset.idx = i;
                setupSlot(slot);
                hbGrid.appendChild(slot);
            }
            document.querySelectorAll('#crafting-grid-2x2 .mc-slot').forEach(setupSlot);
            document.querySelectorAll('#crafting-grid-3x3 .mc-slot').forEach(setupSlot);
            document.getElementById('crafting-output').addEventListener('mousedown', (e) => { if (e.button === 0) handleCraftingOutputClick(); });
        }

        function renderInventory() {
            const updateSlots = (containerId, arr) => {
                const container = document.getElementById(containerId);
                const slots = container.querySelectorAll('.mc-slot');
                arr.forEach((item, i) => { const slot = slots[i]; if (!slot) return; slot.innerHTML = ''; if (item) slot.appendChild(createItemVisual(item.id, item.count)); });
            };
            updateSlots('main-inventory-grid', mainInventory);
            updateSlots('hotbar-inventory-grid', hotbarInventory);
            updateSlots('crafting-grid-2x2', craftingGrid2x2);
            updateSlots('crafting-grid-3x3', craftingGrid3x3);
            checkRecipes();
            const outputSlot = document.getElementById('crafting-output');
            outputSlot.innerHTML = '';
            if (craftingOutput) outputSlot.appendChild(createItemVisual(craftingOutput.id, craftingOutput.count));
            updateHUD();
        }

        function createItemVisual(id, count) {
            const frag = document.createDocumentFragment();
            const block = BLOCK_TYPES[id];
            const icon = document.createElement('div');
            icon.className = 'block-icon';
            
            if (block.toolType) {
                const stick = document.createElement('div');
                stick.className = 'tool-stick'; icon.appendChild(stick);
                const head = document.createElement('div');
                head.className = 'tool-head'; head.style.backgroundColor = block.color; head.style.position = 'absolute';
                head.style.border = `2px solid ${block.stroke}`;
                if (block.toolType === 'pickaxe') { head.style.width = '28px'; head.style.height = '8px'; head.style.top = '4px'; head.style.borderRadius = '2px'; }
                else if (block.toolType === 'shovel') { head.style.width = '14px'; head.style.height = '14px'; head.style.top = '2px'; head.style.borderRadius = '50% 50% 2px 2px'; }
                else if (block.toolType === 'axe') { head.style.width = '18px'; head.style.height = '18px'; head.style.top = '2px'; head.style.left = '4px'; head.style.borderRadius = '2px 10px 2px 2px'; }
                icon.appendChild(head);
            } else if (id === 15) {
                const stick = document.createElement('div'); stick.className = 'tool-stick'; icon.appendChild(stick);
            } else if (id === 59) {
                const flint = document.createElement('div'); flint.style.width = '12px'; flint.style.height = '12px'; flint.style.background = '#424242'; flint.style.borderRadius = '2px';
                const steel = document.createElement('div'); steel.style.width = '14px'; steel.style.height = '8px'; steel.style.background = '#e0e0e0'; steel.style.transform = 'translate(8px, 8px)';
                icon.appendChild(flint); icon.appendChild(steel);
            } else if (id === 60) {
                 icon.style.background = 'radial-gradient(circle, #7b1fa2, #4a148c)'; icon.style.border = '2px solid #fff';
            } else {
                icon.style.backgroundColor = block.color;
                icon.style.border = `2px solid ${block.stroke}`;
                if (block.ore) {
                    for(let i=0; i<3; i++) {
                        const speck = document.createElement('div');
                        speck.style.position = 'absolute'; speck.style.width = '6px'; speck.style.height = '6px'; speck.style.backgroundColor = block.ore;
                        speck.style.left = (Math.random()*24)+'px'; speck.style.top = (Math.random()*24)+'px'; speck.style.borderRadius = '1px'; icon.appendChild(speck);
                    }
                }
                // Bevel effect
                const bevel = document.createElement('div');
                bevel.style.position = 'absolute'; bevel.style.inset = '0'; bevel.style.borderTop = '3px solid rgba(255,255,255,0.2)'; bevel.style.borderLeft = '3px solid rgba(255,255,255,0.2)';
                icon.appendChild(bevel);
            }
            if (count > 1) { const cnt = document.createElement('div'); cnt.className = 'item-count'; cnt.innerText = count; frag.appendChild(cnt); }
            frag.appendChild(icon);
            return frag;
        }

        function handleSlotClick(type, idx, button) {
            let targetArray;
            if (type === 'main') targetArray = mainInventory;
            else if (type === 'hotbar') targetArray = hotbarInventory;
            else if (type === 'craft2') targetArray = craftingGrid2x2;
            else if (type === 'craft3') targetArray = craftingGrid3x3;
            if (!targetArray) return;

            const current = targetArray[idx];
            
            if (button === 0) {
                if (!heldItem && current) { heldItem = { ...current }; targetArray[idx] = null; }
                else if (heldItem && !current) { targetArray[idx] = { ...heldItem }; heldItem = null; }
                else if (heldItem && current) { 
                    if (heldItem.id === current.id) { current.count += heldItem.count; heldItem = null; }
                    else { const temp = { ...current }; targetArray[idx] = { ...heldItem }; heldItem = temp; } 
                }
            } else if (button === 2) {
                if (heldItem) { 
                    if (!current) { targetArray[idx] = { id: heldItem.id, count: 1 }; heldItem.count--; }
                    else if (current.id === heldItem.id) { current.count++; heldItem.count--; } 
                    if (heldItem.count <= 0) heldItem = null; 
                }
                else if (current) { 
                    const take = Math.ceil(current.count / 2); 
                    heldItem = { id: current.id, count: take }; 
                    current.count -= take; 
                    if (current.count <= 0) targetArray[idx] = null; 
                }
            }
            updateHeldItemCursor(); 
            renderInventory();
        }

        function handleCraftingOutputClick() {
            if (craftingOutput && activeRecipeMatch && (!heldItem || heldItem.id === craftingOutput.id)) {
                if (!heldItem) heldItem = { ...craftingOutput }; else heldItem.count += craftingOutput.count;
                const grid = isUsingTable ? craftingGrid3x3 : craftingGrid2x2;
                const match = activeRecipeMatch;
                const recipe = match.recipe;
                const offsetX = match.offsetX;
                const offsetY = match.offsetY;
                const gridWidth = isUsingTable ? 3 : 2;
                for (let r = 0; r < recipe.pattern.length; r++) {
                    for (let c = 0; c < recipe.pattern[r].length; c++) {
                        const ingId = recipe.pattern[r][c];
                        if (ingId !== null) {
                            const gridIdx = (r + offsetY) * gridWidth + (c + offsetX);
                            grid[gridIdx].count--;
                            if (grid[gridIdx].count <= 0) grid[gridIdx] = null;
                        }
                    }
                }
                renderInventory();
            }
        }

        function checkRecipes() {
            const grid = isUsingTable ? craftingGrid3x3 : craftingGrid2x2;
            const gridWidth = isUsingTable ? 3 : 2;
            const gridHeight = isUsingTable ? 3 : 2;
            let minX = gridWidth, maxX = -1, minY = gridHeight, maxY = -1;
            let totalItemsInGrid = 0;
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const item = grid[y * gridWidth + x];
                    if (item) {
                        minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                        totalItemsInGrid++;
                    }
                }
            }
            if (totalItemsInGrid === 0) { craftingOutput = null; activeRecipeMatch = null; return; }
            const subWidth = maxX - minX + 1;
            const subHeight = maxY - minY + 1;
            const subGrid = [];
            for (let y = 0; y < subHeight; y++) {
                subGrid[y] = [];
                for (let x = 0; x < subWidth; x++) {
                    const item = grid[(y + minY) * gridWidth + (x + minX)];
                    subGrid[y][x] = item ? item.id : null;
                }
            }
            let bestMatch = null;
            for (const recipe of RECIPES) {
                const p = recipe.pattern;
                const pHeight = p.length;
                const pWidth = p[0].length;
                if (subWidth !== pWidth || subHeight !== pHeight) continue;
                let matches = true;
                for (let r = 0; r < pHeight; r++) {
                    for (let c = 0; c < pWidth; c++) {
                        if (subGrid[r][c] !== p[r][c]) { matches = false; break; }
                    }
                    if (!matches) break;
                }
                if (matches) { bestMatch = { recipe: recipe, offsetX: minX, offsetY: minY }; break; }
            }
            if (bestMatch) {
                craftingOutput = { id: bestMatch.recipe.result, count: bestMatch.recipe.amount };
                activeRecipeMatch = bestMatch;
            } else {
                craftingOutput = null; activeRecipeMatch = null;
            }
        }

        function updateHeldItemCursor() {
            const cursor = document.getElementById('held-item-cursor');
            if (heldItem) { 
                cursor.style.display = 'block'; 
                cursor.style.left = (mouse.x + 12) + 'px'; 
                cursor.style.top = (mouse.y + 12) + 'px'; 
                cursor.innerHTML = ''; 
                cursor.appendChild(createItemVisual(heldItem.id, heldItem.count)); 
            }
            else { cursor.style.display = 'none'; }
        }

        function addItemToInventory(id, count) {
            const lists = [hotbarInventory, mainInventory];
            for (const list of lists) { 
                for (let i = 0; i < list.length; i++) { 
                    if (list[i] && list[i].id === id) { list[i].count += count; return true; } 
                } 
            }
            for (const list of lists) { 
                for (let i = 0; i < list.length; i++) { 
                    if (!list[i]) { list[i] = { id, count }; return true; } 
                } 
            }
            return false;
        }

        function handleWorldInteraction() {
            if (player.dead || inventoryOpen) return;
            const world = worlds[currentDimension];
            const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
            const wy = Math.floor((mouse.y + camera.y) / TILE_SIZE);
            if (wx < 0 || wx >= WORLD_WIDTH || wy < 0 || wy >= WORLD_HEIGHT) return;
            const key = `${wx},${wy}`;
            
            if (mouse.rightDown) {
                const activeItem = hotbarInventory[activeHotbarIndex];
                if (activeItem && activeItem.id === 59) { 
                    if (world[key] === 28) tryIgnitePortal(wx, wy);
                    return;
                }
                if (world[key]) { if (BLOCK_TYPES[world[key]].table) { toggleInventory(true); return; } }
                if (activeItem && !world[key] && !BLOCK_TYPES[activeItem.id].item) {
                    const rect = { x: wx * TILE_SIZE, y: wy * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE };
                    if (!checkOverlap(player, rect)) { 
                        world[key] = activeItem.id; activeItem.count--; 
                        if (activeItem.count <= 0) hotbarInventory[activeHotbarIndex] = null; 
                        updateHUD(); 
                    }
                }
            }
        }

        function tryIgnitePortal(wx, wy) {
            const world = worlds[currentDimension];
            for(let sx = wx - 4; sx <= wx + 4; sx++) {
                for(let sy = wy - 5; sy <= wy + 5; sy++) {
                    if(world[`${sx},${sy}`] === 28 && world[`${sx+3},${sy}`] === 28) {
                        let isFrame = true;
                        for(let x=0; x<4; x++) if(world[`${sx+x},${sy}`] !== 28 || world[`${sx+x},${sy+4}`] !== 28) isFrame = false;
                        for(let y=0; y<5; y++) if(world[`${sx},${sy+y}`] !== 28 || world[`${sx+3},${sy+y}`] !== 28) isFrame = false;
                        if(isFrame) {
                            for(let x=1; x<=2; x++) for(let y=1; y<=3; y++) world[`${sx+x},${sy+y}`] = 60;
                            createParticles((sx+1.5)*TILE_SIZE, (sy+2)*TILE_SIZE, '#6a1b9a', 20);
                            return;
                        }
                    }
                }
            }
        }

        function updateHUD() {
            const hud = document.getElementById('hotbar-hud');
            hud.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const item = hotbarInventory[i];
                const slot = document.createElement('div');
                slot.className = `hud-slot ${activeHotbarIndex === i ? 'active' : ''}`;
                if (item) slot.appendChild(createItemVisual(item.id, item.count));
                hud.appendChild(slot);
            }
            document.getElementById('dim-indicator').innerText = currentDimension === 'overworld' ? 'Overworld' : 'The Nether';
            document.getElementById('dim-indicator').style.color = currentDimension === 'overworld' ? '#ffb6c1' : '#ff4d4d';
        }

        function updateHeartsUI() { heartsContainer.innerHTML = ''; for(let i=0; i<MAX_HEALTH; i++) { const heart = document.createElement('div'); heart.className = `heart ${i >= player.health ? 'empty' : ''}`; heartsContainer.appendChild(heart); } }

        function generateOverworld() {
            const world = worlds.overworld;
            const surfaceHeights = [];
            const seed = Math.random() * 1000;
            const roughness = 0.05;
            const amplitude = 8;
            const baseHeight = 40;
            for (let x = 0; x < WORLD_WIDTH; x++) {
                const surfaceY = Math.floor(Math.sin(x * roughness + seed) * amplitude + baseHeight);
                surfaceHeights[x] = surfaceY;
                for (let y = surfaceY; y < WORLD_HEIGHT; y++) {
                    let type = 2; if (y === surfaceY) type = 1;
                    if (y === WORLD_HEIGHT - 1) type = 29; 
                    else if (y > surfaceY + 8) {
                        type = 3; 
                        if (y > surfaceY + 12 && Math.random() < 0.1) type = 13;
                        if (Math.random() < 0.05) type = 57; 
                        if (y > surfaceY + 20 && Math.random() < 0.06) type = 14;
                        if (y > surfaceY + 50 && Math.random() < 0.02) type = 26;
                        if (y > surfaceY + 60 && Math.random() < 0.015) type = 28;
                    }
                    if (y > surfaceY + 25 && y < WORLD_HEIGHT - 1 && Math.random() < 0.01) type = 6;
                    world[`${x},${y}`] = type;
                }
            }
            for (let x = 2; x < WORLD_WIDTH - 2; x++) {
                if (Math.random() < 0.1) {
                    const groundY = surfaceHeights[x];
                    if (world[`${x},${groundY}`] === 1) {
                        const th = 4 + Math.floor(Math.random()*2);
                        for (let i=1; i<=th; i++) world[`${x},${groundY-i}`] = 4;
                        for (let lx=-2; lx<=2; lx++) for (let ly=-2; ly<=0; ly++) if(!world[`${x+lx},${groundY-th+ly}`] && Math.abs(lx)+Math.abs(ly) < 4) world[`${x+lx},${groundY-th+ly}`] = 5;
                    }
                }
            }
        }

        function generateNether() {
            const world = worlds.nether;
            const seed = Math.random() * 2000;
            for (let x = 0; x < WORLD_WIDTH; x++) {
                for(let y=0; y<5; y++) world[`${x},${y}`] = 51;
                for(let y=WORLD_HEIGHT-5; y<WORLD_HEIGHT; y++) world[`${x},${y}`] = 51;
                for(let y=WORLD_HEIGHT-10; y<WORLD_HEIGHT-5; y++) world[`${x},${y}`] = 6;
                for (let y = 10; y < WORLD_HEIGHT - 15; y++) {
                    const noise = Math.sin(x * 0.1 + seed) * Math.cos(y * 0.1 + seed);
                    if (noise > 0.4) {
                        let type = 51;
                        if (Math.random() < 0.05) type = 61; 
                        if (Math.random() < 0.02) type = 62; 
                        if (Math.random() < 0.01) type = 52; 
                        world[`${x},${y}`] = type;
                    }
                }
            }
        }

        function checkOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
        function takeDamage(amt) { if (player.invuln > 0 || player.dead) return; player.health -= amt; player.invuln = INVULN_TIME; updateHeartsUI(); if (player.health <= 0) die(); player.vy = -5; }
        function die() { player.dead = true; document.getElementById('death-screen').style.display = 'flex'; }
        function respawn() { 
            player.health = MAX_HEALTH; player.dead = false; 
            currentDimension = 'overworld'; 
            player.x = (WORLD_WIDTH/2) * TILE_SIZE; player.y = 0;
            const world = worlds[currentDimension];
            let startY = 0;
            while(!world[`${Math.floor(player.x/TILE_SIZE)},${startY}`] && startY < WORLD_HEIGHT) startY++;
            player.y = (startY - 2) * TILE_SIZE;
            updateHeartsUI(); updateHUD(); document.getElementById('death-screen').style.display = 'none'; 
        }

        function getMiningSpeed() {
            const activeItem = hotbarInventory[activeHotbarIndex];
            if (!miningTarget) return 1;
            const world = worlds[currentDimension];
            const targetBlock = world[miningTarget.key];
            if (!targetBlock) return 1;
            const block = BLOCK_TYPES[targetBlock];
            if (block.id === 29) return 0;
            if (!activeItem) return 1;
            const tool = BLOCK_TYPES[activeItem.id];
            if (!tool || !tool.toolType) return 1;
            if (block.tool === tool.toolType) return 1 + (tool.tier * 6);
            return 1;
        }

        function update() {
            if (!gameStarted || player.dead || inventoryOpen) return;
            if (player.invuln > 0) player.invuln--;
            
            const world = worlds[currentDimension];

            // Update Particles
            particles = particles.filter(p => {
                p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life--; return p.life > 0;
            });

            // Teleport Logic
            const px = Math.floor((player.x + player.w/2) / TILE_SIZE);
            const py = Math.floor((player.y + player.h/2) / TILE_SIZE);
            if (world[`${px},${py}`] === 60) {
                teleportTimer++;
                portalOverlay.style.opacity = teleportTimer / 60;
                if (teleportTimer >= 60) {
                    currentDimension = currentDimension === 'overworld' ? 'nether' : 'overworld';
                    teleportTimer = 0;
                    portalOverlay.style.opacity = 0;
                    const targetWorld = worlds[currentDimension];
                    let found = false;
                    for(let x=0; x<WORLD_WIDTH && !found; x++) {
                        for(let y=0; y<WORLD_HEIGHT && !found; y++) {
                            if(targetWorld[`${x},${y}`] === 60) {
                                player.x = x * TILE_SIZE; player.y = (y-1) * TILE_SIZE; found = true;
                            }
                        }
                    }
                    if(!found) {
                        player.x = (WORLD_WIDTH/2) * TILE_SIZE;
                        let startY = 0;
                        while(!targetWorld[`${Math.floor(player.x/TILE_SIZE)},${startY}`] && startY < WORLD_HEIGHT) startY++;
                        player.y = (startY - 2) * TILE_SIZE;
                    }
                    updateHUD();
                }
            } else {
                teleportTimer = 0;
                portalOverlay.style.opacity = 0;
            }

            if (mouse.down) {
                const wx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
                const wy = Math.floor((mouse.y + camera.y) / TILE_SIZE);
                const key = `${wx},${wy}`;
                const targetBlock = world[key];
                if (targetBlock) {
                    if (miningTarget && miningTarget.key === key) {
                        miningProgress += getMiningSpeed();
                        const block = BLOCK_TYPES[targetBlock];
                        if (Math.random() < 0.3) createParticles((wx+0.5)*TILE_SIZE, (wy+0.5)*TILE_SIZE, block.color, 1);
                        if (miningProgress >= block.hardness) { 
                            let dropId = block.dropId || block.drop || targetBlock;
                            addItemToInventory(dropId, 1); 
                            createParticles((wx+0.5)*TILE_SIZE, (wy+0.5)*TILE_SIZE, block.color, 8);
                            delete world[key]; updateHUD(); miningTarget = null; miningProgress = 0; 
                        }
                    } else { miningTarget = { wx, wy, key }; miningProgress = 0; }
                } else { miningTarget = null; miningProgress = 0; }
            } else { miningTarget = null; miningProgress = 0; }

            let curSpeed = keys['shift'] ? SPRINT_SPEED : SPEED;
            let maxH = keys['shift'] ? 10 : 7;
            if (keys['a'] || keys['arrowleft']) { player.vx -= curSpeed; player.facing = -1; player.animTimer += 0.2; }
            if (keys['d'] || keys['arrowright']) { player.vx += curSpeed; player.facing = 1; player.animTimer += 0.2; }
            player.vx *= FRICTION; 
            player.x += player.vx; resolveCollision('x');
            if ((keys['w'] || keys[' '] || keys['arrowup']) && player.grounded) { player.vy = JUMP; player.grounded = false; player.squash = 1.3; }
            player.vy += GRAVITY; player.y += player.vy; 
            
            // Squash Logic
            player.squash += (1 - player.squash) * 0.15;
            
            player.grounded = false;
            if (player.y + player.h > WORLD_HEIGHT * TILE_SIZE) takeDamage(10); resolveCollision('y');
            camera.x += (player.x - width/2 - camera.x) * 0.1; camera.y += (player.y - height/2 - camera.y) * 0.1;
            document.getElementById('coords').innerText = `X: ${Math.floor(player.x/TILE_SIZE)} Y: ${Math.floor(player.y/TILE_SIZE)}`;
        }

        function resolveCollision(axis) {
            const world = worlds[currentDimension];
            const x1 = Math.floor(player.x / TILE_SIZE), x2 = Math.floor((player.x + player.w - 1) / TILE_SIZE);
            const y1 = Math.floor(player.y / TILE_SIZE), y2 = Math.floor((player.y + player.h - 1) / TILE_SIZE);
            for (let x = x1; x <= x2; x++) {
                for (let y = y1; y <= y2; y++) {
                    const type = world[`${x},${y}`];
                    if (type) {
                        const block = BLOCK_TYPES[type]; 
                        if (block.hazard) { takeDamage(1); if (block.id !== 6) continue; }
                        if (block.teleport) continue; 
                        if (axis === 'x') { if (player.vx > 0) player.x = x * TILE_SIZE - player.w; else if (player.vx < 0) player.x = (x + 1) * TILE_SIZE; player.vx = 0; }
                        else { 
                            if (player.vy > 0) { 
                                if (!player.grounded) player.squash = 0.7;
                                player.y = y * TILE_SIZE - player.h; player.grounded = true; 
                            } else if (player.vy < 0) { player.y = (y + 1) * TILE_SIZE; } player.vy = 0; 
                        }
                    }
                }
            }
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }

        function drawBlock(x, y, type) {
            const b = BLOCK_TYPES[type];
            const tx = x * TILE_SIZE;
            const ty = y * TILE_SIZE;
            const time = Date.now() / 300;

            // Base Block
            ctx.fillStyle = b.color;
            if (b.animated) {
                if (type === 60) ctx.fillStyle = `hsl(${280 + Math.sin(time + x + y) * 30}, 70%, 30%)`;
                if (type === 6 || type === 62) ctx.fillStyle = `hsl(${15 + Math.sin(time + x * 0.5) * 5}, 90%, ${40 + Math.sin(time + y) * 10}%)`;
                if (type === 52) ctx.fillStyle = `hsl(50, 90%, ${70 + Math.sin(time) * 10}%)`;
            }
            ctx.fillRect(tx, ty, TILE_SIZE, TILE_SIZE);

            // Special Textures
            if (type === 1) { // Grass
                ctx.fillStyle = b.topColor;
                ctx.fillRect(tx, ty, TILE_SIZE, 8);
                ctx.fillRect(tx, ty+8, 4, 4); ctx.fillRect(tx+12, ty+8, 8, 4); ctx.fillRect(tx+28, ty+8, 6, 4);
            } else if (b.texture === 'stone' || b.texture === 'cobble' || b.texture === 'netherrack') {
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(tx+4, ty+4, 8, 8); ctx.fillRect(tx+20, ty+18, 12, 12);
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fillRect(tx+25, ty+5, 6, 6); ctx.fillRect(tx+8, ty+25, 10, 10);
            }

            if (b.ore) {
                ctx.fillStyle = b.ore;
                ctx.fillRect(tx+6, ty+8, 6, 6); ctx.fillRect(tx+24, ty+14, 8, 8); ctx.fillRect(tx+10, ty+26, 6, 6);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(tx+6, ty+8, 2, 2); ctx.fillRect(tx+24, ty+14, 3, 3);
            }

            if (type === 11) { // Clock
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(tx + TILE_SIZE/2, ty + TILE_SIZE/2, TILE_SIZE/2.5, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(tx + TILE_SIZE/2, ty + TILE_SIZE/2);
                const angle = time;
                ctx.lineTo(tx + TILE_SIZE/2 + Math.cos(angle)*10, ty + TILE_SIZE/2 + Math.sin(angle)*10);
                ctx.stroke();
            }

            // Highlighting / Bevel
            ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 2;
            ctx.strokeRect(tx+1, ty+1, TILE_SIZE-2, TILE_SIZE-2);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.strokeRect(tx, ty, TILE_SIZE, TILE_SIZE);
            
            // Mining Stage
            if (miningTarget && miningTarget.wx === x && miningTarget.wy === y) {
                const stage = Math.floor((miningProgress / b.hardness) * 5);
                if (stage > 0) {
                    ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 3;
                    for (let i = 0; i < stage; i++) {
                        ctx.beginPath(); ctx.moveTo(tx+(i*8), ty); ctx.lineTo(tx+TILE_SIZE, ty+TILE_SIZE-(i*8)); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(tx, ty+(i*8)); ctx.lineTo(tx+TILE_SIZE-(i*8), ty+TILE_SIZE); ctx.stroke();
                    }
                }
            }
        }

        function draw() {
            const bgColor = currentDimension === 'overworld' ? '#4a90e2' : '#1a0505';
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, width, height);
            
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            
            const world = worlds[currentDimension];
            const v1 = Math.max(0, Math.floor(camera.x/TILE_SIZE)-1), v2 = Math.min(WORLD_WIDTH-1, Math.ceil((camera.x+width)/TILE_SIZE)+1);
            const v3 = Math.max(0, Math.floor(camera.y/TILE_SIZE)-1), v4 = Math.min(WORLD_HEIGHT-1, Math.ceil((camera.y+height)/TILE_SIZE)+1);

            for (let x = v1; x <= v2; x++) {
                for (let y = v3; y <= v4; y++) {
                    const type = world[`${x},${y}`];
                    if (type) drawBlock(x, y, type);
                }
            }

            // Draw Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 50;
                ctx.fillRect(p.x, p.y, 6, 6);
            });
            ctx.globalAlpha = 1;

            // Draw Player (Detailed Pig)
            if (!player.dead && player.invuln % 6 < 3) {
                ctx.save(); 
                ctx.translate(player.x + player.w/2, player.y + player.h);
                ctx.scale(player.facing, player.squash);
                ctx.translate(-player.w/2, -player.h);

                // Body
                ctx.fillStyle = '#ffb6c1';
                ctx.fillRect(0, 4, player.w, player.h - 10);
                ctx.strokeStyle = '#ff69b4'; ctx.lineWidth = 2;
                ctx.strokeRect(0, 4, player.w, player.h - 10);

                // Legs
                const legOffset = Math.sin(player.animTimer) * 6;
                ctx.fillStyle = '#ffb6c1';
                ctx.fillRect(4, player.h - 8, 8, 8 + (player.grounded ? 0 : 2));
                ctx.fillRect(player.w - 12, player.h - 8, 8, 8 - (player.grounded ? 0 : 2));
                
                // Snout
                ctx.fillStyle = '#ff69b4';
                ctx.fillRect(player.w - 6, 12, 10, 10);
                ctx.fillStyle = '#c71585';
                ctx.fillRect(player.w + 1, 15, 2, 2); ctx.fillRect(player.w + 1, 19, 2, 2);

                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(player.w - 10, 8, 4, 4);

                // Tail
                ctx.strokeStyle = '#ff69b4'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, 10); ctx.quadraticCurveTo(-10, 5, -5, 0); ctx.stroke();

                ctx.restore();
            }
            ctx.restore();
        }
        init();
    </script>
</body>
</html>
